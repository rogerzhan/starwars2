#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <crtdbg.h>
#include "logMsg.h"
#include <string.h>
#include "datetime.h"
#include "localTime.h"
#include "CSHOpt_struct.h"
#include "CSHOpt_processInput.h"
#include "CSHOpt_dutyNodes.h"
#include "CSHOpt_tours.h"
#include "CSHOpt_scheduleSolver.h"
#include "CSHOpt_output.h"
#include "CSHOpt_readInput.h"
#include "CSHOpt_callOag.h"
#include "DutyLine.h"
#include <ilcplex/cplex.h>
#include "my_mysql.h"

#define DL_MAX_NUM_AC_PER_DUTY 2
#define DL_MAX_NUM_ALT_AC_PER_DUTY 2
#define DL_MAX_NUM_TRAVEL_PER_PILOT 2
#define DL_MAX_NUM_DUTY_PER_COL 5

#define DL_F_CHECK_DATA_DEBUG
//#define DL_F_PRINT_DATA_DEBUG
#define DL_F_SOLUTION_DEBUG
//#define DL_F_LP_WRITE_DEBUG
//#define DL_F_LP_COL_CHECK_DEBUG


//external
extern OptParameters optParam;
extern int verbose;
extern FILE *dlFile;
extern time_t firstEndOfDay;
extern int month;
extern int withOag;
extern char logFileName[512];//main.c
extern int  local_scenarioid;


extern Crew *crewList;
extern int numCrew;
extern Demand *demandList;
extern int numDemand;
extern ProposedMgdLeg *propMgdLegs ;
extern int numPropMgdLegs ;
extern CrewPair *crewPairList;
extern int numCrewPairs;
extern Aircraft *acList;
extern int numAircraft;
extern AircraftType *acTypeList;
extern int numAcTypes;
extern OrigDemInfo *origDemInfos; //original demand list
extern int numOrigDem;

extern time_t *outTimes ;//will be updated in this file
extern time_t *inTimes ;//will be updated in this file

extern ExgTour *optExgTours ;
extern int numOptExgTours ;
extern int *optSolution ;

ProposedCrewAssg *dlCrewAssigns = NULL;
int numDlCrewAssigns = 0;

typedef enum 
{
	DL_FromExist=0,
	DL_FromNew,
	DL_NewAvail
} DL_CpAcStartType ;

typedef enum 
{
	DL_NotAvail=0,
	DL_AfterLeg,
	DL_AfterAppCol,
	DL_AfterAvail
} DL_AvailType ;

typedef enum 
{
	DL_DemNotUsed=0,
	DL_DemInNewTour,
	DL_DemInExgTour,
	DL_DemInAppCol
} DL_DemUsedType ;

typedef enum 
{
	DL_KO_NotKeep=0,
	DL_KO_TmFixed,
	DL_KO_Combined,
	DL_KO_DutyTime,
	DL_KO_NoTravel
} DL_KeepOriginalType ;

typedef enum 
{
	DL_NotFixed=0,
	DL_StartTmFixed,
	DL_EndTmFixed,
	DL_BothTmFixed,
	DL_DutyCombined
} DL_TmFixType ;

typedef enum 
{
	DL_Row_StartInfo = 0,
	DL_Row_StartInfo_Con,
	DL_Row_StartInfo_ConTm,
	DL_Row_Pilot,
	DL_Row_PilotTm,
	DL_Row_Ac,
	DL_Row_AcTm,
	DL_Row_OptDuty,
	DL_Row_CrewedAc,
	DL_Row_CvdDem,
	DL_Row_CvdReg,
	DL_Row_Total
} DL_RowType ; //update NumRowTypes if add new row types

typedef enum 
{
	DL_Col_LP = 0,
	DL_Col_Dem,
	DL_Col_Ac,
	DL_Col_Total
} DL_ColType ;//update NumColTypes if add new row types

typedef struct dl_LegInfo
{
	int legInd ;
	int legIndCP;
	int acInd ;
	int day ;
	int schOutDay ;
	int schInDay ;
	const ProposedMgdLeg *leg ;
	struct dl_LegInfo *prevPilotLegs[2] ;
	struct dl_LegInfo *nextPilotLegs[2] ;
	struct dl_LegInfo *prevAcLeg ;
	struct dl_LegInfo *nextAcLeg ;
	char noAcTurn[2];
	char noPilotRest[2][2];
} DL_LegInfo ;

typedef struct dl_AvailInfo
{
	int ind ;
	int status;
	DL_AvailType availAfter;
	time_t tm;
	time_t dutyStartTm;
	time_t latestLegEndB4HTravel;
	int apt ;
	int inLegs;
	int day;
} DL_AvailInfo ;

//current cp-ac-duty (from the opt solution)
typedef struct dl_CpAcAssign
{
	int dutyNum;//temp
	int acInd[DL_MAX_NUM_AC_PER_DUTY];
	int acEndLeg[DL_MAX_NUM_AC_PER_DUTY];
	int numAc;
	int pilotDays[2];
	DL_LegInfo *firstLegP ;
	DL_LegInfo *lastLegP ;
	DL_TmFixType tmFixed ;
} DL_CpAcAssign ;

typedef struct dl_CpAcStartInfo
{
	//int tourInd ;
	int index;
	DL_CpAcStartType type ;
	int acTypeInd;
	int cpInd ;
	time_t firstLegStart ; //0 if no legs

	DL_AvailInfo acAvail;
	DL_AvailInfo pilotAvail[2];

	//days
	int acCpDay ;
	int legStartDay ;
	int legEndDay ;
	int lastPossibleDay;

	struct dl_CpAcStartInfo* acNext;
	struct dl_CpAcStartInfo* pilotNext[2];
} DL_CpAcStartInfo ;

//duty column in the model
typedef struct dl_Column
{
	const DL_CpAcStartInfo *startInfoP;
	const DL_CpAcAssign *cpAcAssignP;

	//int cpInd;
	int acInd;

	time_t startTm;
	time_t endTm;
	time_t pilotStartTm[2] ;
	time_t pDutyStartTm[2] ;
	
	int acAirport;
	time_t acTm;
	time_t pTm[2];
	int pAirports[2];
	
	DL_KeepOriginalType keepOriginal;
	double cost;
	int firstDay;
	int day;

	int *coverDems;
	int numCoverDems;
	double *coverDemCoefs;
	int *coverRegions;
	int numCoverRegions;
	double *coverRegionCoefs;
} DL_Column;

typedef struct dl_LpColumn
{
	DL_Column *col;
	int fDuty;
	int dropOff;
	int nextDay;
} DL_LpColumn ;

//temp data for generating a one-day-duty-assignment
typedef struct dl_DataOneDay
{
	const DL_CpAcStartInfo *startInfoP;
	const DL_CpAcAssign *cpAcAssignP;

	time_t eStartTm;
	time_t lStartTm;
	time_t eEndTm;
	time_t lEndTm;
	
	int acInd;
	int acAirport;
	time_t acTm;
	time_t pTm[2];
	int pAirports[2];
	time_t pilotStartTm[2];
	
	DL_KeepOriginalType keepOriginal;
	int firstDay;
	int day;
} DL_DataOneDay;

//log file
FILE *dlFile = NULL ;

//constant
static const int Minute = 60 ;
static const int Hour = 3600 ;
static const int DayInSecs = 24*3600 ;
static const int DefaultAllocSize = 128;
static const int NewAssignDefaultAllocSize = 16;
static const int TourColDefaultAllocSize = 2048;
static const int IndAllocSize = 5;
static const time_t DiscrtCrewInterval = 3600;//discretize the crewing time interval
static const time_t DiscrtLPInterval = 1800;
static const time_t MinCrewInterval = 3600*4;//minimal crewing interval
static const time_t RecoverDeptDelay = 3*3600;//daparture time delay for contingancy

static const int PilotRestB4Leg = 128;
static const int PilotRestB4FirstLeg = 129;
static const int PilotInDuty = 0;

static const int PilotStartLater = 128;
static const int PilotAfterDuty = 129;

static const int NumRowTypes = 12;
static const int NumColTypes = 4;

static newAssignCount = 0;
	
//first leg start time, acInd, cpInd
static int compareCpAcStartInfo (const DL_CpAcStartInfo *a, const DL_CpAcStartInfo *b);

static int compareLpColumn (const DL_LpColumn *a, const DL_LpColumn *b);

//acID, start time
static int compareMgdLegsAC (const ProposedMgdLeg *a, const ProposedMgdLeg *b);

//CP ind, start time
//static int compareMgdLegsCP (const ProposedMgdLeg *a, const ProposedMgdLeg *b);

static int compareLegInfoCP (const DL_LegInfo *a, const DL_LegInfo *b);

static int compareDlColumn (const DL_Column *a, const DL_Column *b);

static int compareCrewAssign (const ProposedCrewAssg *a, const ProposedCrewAssg *b);

static DL_Column *allocAnAssignment(DL_Column **assignmentsP, int *countP);

static DL_LpColumn *allocAnLpColumn(DL_LpColumn **lpColsP, int *countP);

static DL_CpAcStartInfo *allocAStartInfo(DL_CpAcStartInfo **cpAcStartInfosP, int *countP);

static int *allocCvdDemForCL( DL_Column *inP);

//get list of long maintenance: long to re-assign
static int generateLongMaintlInfo(const DL_DemUsedType *dlDemUsed, int **longMaintP, int *numLongMaintP);

static int generateLegsCP( DL_LegInfo **legInfosCPP );

static int generateCurrentCpDutyAssign(const DL_DemUsedType *dlDemUsed, DL_LegInfo *legInfosCP, DL_CpAcAssign ***cpAcAssignsP ) ;

//get list of additional optimal tour information for each optimal tour: same cpInd and acInd ( not including existing tours)
//sorted in the increasing order of first leg start time
static int generateCpAcStartInfo(const DL_DemUsedType *dlDemUsed, const DL_LegInfo *legInfosCP, const DL_CpAcAssign **cpAcAssigns, const int *longMaint
, const int numLongMaint, DL_CpAcStartInfo **cpAcStartInfosP, int *numStartInfoP, DL_AvailInfo **availAcsP, DL_AvailInfo **availPilotsP);

static int generateAnAssignment( const DL_AvailInfo *availPilots, const DL_CpAcAssign **cpAcAssigns, const DL_CpAcStartInfo *startP, const int dayZero, const int dayOne, DL_Column **assignmentsP, int *numAssignmentsP) ;

static int timeToDay(const time_t timeT) ;

static int acIDToInd(const int acID) ;

static int getDayFromMgdLegs(const DL_DemUsedType *dlDemUsed, const DL_LegInfo *legInfosCP, const int sInd, const int eInd, int *dayP);

static int getAcIndFromMgdLegs(const DL_LegInfo *legInfosCP,  const int sInd, const int eInd, int *acInd, int *acEndLeg, int *numAcP ) ;

static int printManagedLegs(const DL_LegInfo *legInfosCP ) ;

static int printLongMaintlInfo(const int *longMaint, const int numLongMaint) ;

static int printCurrentCpDutyAssign(const DL_CpAcAssign **cpAcAssigns) ;

static int checkCurrentCpDutyAssign(const DL_CpAcAssign **cpAcAssigns, const DL_LegInfo *legInfosCP) ;

static int printCpAcStartInfo( const DL_CpAcStartInfo *cpAcStartInfos, const int numStartInfo, const DL_AvailInfo *availAcs, const DL_AvailInfo *availPilots);

static int checkCpAcStartInfo(const DL_LegInfo *legInfosCP, const DL_CpAcAssign **cpAcAssigns, const DL_CpAcStartInfo *cpAcStartInfos, 
const int numStartInfo, const DL_AvailInfo *availAcs, const DL_AvailInfo *availPilots );

static int printNewAssigns( const DL_Column ****newAssigns, const int ***numNewAssigns, const int numStartInfo);

static int checkLegsCP(const DL_LegInfo *legInfosCP) ;

static int colMove ( DL_Column *destP, const DL_Column *origP );

static int colFree( DL_Column *origP );

static int cpIntersect( const int fInd, const int sInd, int *pIndF, int *pIndS );

static int generateColumns( const DL_AvailInfo *availPilots, const DL_CpAcAssign **cpAcAssigns, const DL_CpAcStartInfo *cpAcStartInfos, const int numStartInfo
, DL_Column *****naP, int ****numNAP) ;

static int checkColumns(const DL_LegInfo *legInfosCP, const DL_CpAcAssign **cpAcAssigns, const DL_CpAcStartInfo *cpAcStartInfos, const int numStartInfo
, const DL_Column ****naP, const int ***numNAP);

static int generateAnAssignmentA(DL_DataOneDay* tmpDataP, const int numTmpData, DL_Column **assignmentsP, int *numAssignmentsP) ;

static int optDutyLineB (const DL_CpAcAssign **cpAcAssigns, const DL_CpAcStartInfo *cpAcStartInfos, const int numStartInfo, const DL_AvailInfo *availAcs
, const DL_AvailInfo *availPilots, DL_Column ****naP, const int ***numNAP, const DL_LegInfo *legInfosCP, ProposedCrewAssg **crewAssignP, int *numCrewAssignP);

static int printAndCheckSolution ( const CPXENVptr env, const CPXLPptr lp, const DL_CpAcStartInfo *cpAcStartInfos, const int numStartInfo, const DL_AvailInfo *availAcs
, const DL_AvailInfo *availPilots, const int *colStartInd, const int *dColToDInd, const int *aColToAInd, const DL_LpColumn *lpCols, const DL_LegInfo *legInfosCP
, const DL_CpAcAssign **cpAcAssigns, ProposedCrewAssg **crewAssignP, int *numCrewAssignP ) ;

int getDemUsed(DL_DemUsedType **dlDemUsedP);

static time_t getCurMaxDutyTm(const int firstDuty, const time_t curTime, const int curApt );

int dutyLine(ProposedCrewAssg **crewAssignP, int *numCrewAssignP )
{
	int i, j, k, numAssignments = 0, fDay, numLongMaint = 0, numStartInfo = 0;
	char dlFileName[512] ;
	time_t startTm, endTm;
	
	int *longMaint = NULL;
	DL_LegInfo *legInfosCP = NULL;
	DL_CpAcAssign **cpAcAssigns = NULL ;
	DL_CpAcStartInfo *cpAcStartInfos = NULL;
	DL_Column ****newAssigns = NULL ;
	int ***numNewAssigns = NULL ;
	DL_AvailInfo *availAcs=NULL, *availPilots=NULL ;
	DL_DemUsedType *dlDemUsed=NULL;

	int *regions = NULL; //temp

	startTm = time(NULL) ;
	printf("\n Duty Line ... \n") ;
/////////////////////////////////////////////////////////////////////////////////////////////set the output file
	memset(dlFileName, 0, sizeof(dlFileName));
	for(i=0; i < sizeof(logFileName) - 1; i++)
		if( logFileName[i] == '.' && logFileName[i+1] == 't') //remove .txt from the file name
			break;
		else
			dlFileName[i] = logFileName[i];
	_ASSERTE( sizeof(logFileName) == sizeof(dlFileName) && i +12 < sizeof(logFileName)); //will add _output.xml
	dlFileName[i] = '\0';//add end
	strcat(dlFileName, "_DutyLine.txt");
	if( (dlFile = fopen (dlFileName, "w")) == NULL)
	{
		logMsg(dlFile,"%s Line %d: Cannot write Duty Line file.\n", __FILE__,__LINE__);
		exit(1);
	}
/////////////////////////////////////////////////////////////////////////////////////////////end

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	getDemUsed(&dlDemUsed) ;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	generateLegsCP( &legInfosCP );
#ifdef DL_F_PRINT_DATA_DEBUG
	printManagedLegs( legInfosCP ) ;
#endif
#ifdef DL_F_CHECK_DATA_DEBUG
	checkLegsCP(legInfosCP) ;
#endif
	
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	generateLongMaintlInfo(dlDemUsed, &longMaint, &numLongMaint) ;//get long maint that are in the solution
#ifdef DL_F_PRINT_DATA_DEBUG
	printLongMaintlInfo(longMaint, numLongMaint) ;
#endif

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	generateCurrentCpDutyAssign( dlDemUsed, legInfosCP, &cpAcAssigns ) ;	//generate assignment of ac-pilot-duty on each day, according to the optimal solution
#ifdef DL_F_PRINT_DATA_DEBUG
	printCurrentCpDutyAssign(cpAcAssigns) ;
#endif
#ifdef DL_F_CHECK_DATA_DEBUG
	checkCurrentCpDutyAssign(cpAcAssigns, legInfosCP) ;
#endif

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	generateCpAcStartInfo(dlDemUsed, legInfosCP, cpAcAssigns, longMaint, numLongMaint, &cpAcStartInfos, &numStartInfo, &availAcs, &availPilots);
#ifdef DL_F_PRINT_DATA_DEBUG
	printCpAcStartInfo(cpAcStartInfos, numStartInfo, availAcs, availPilots) ;
#endif
#ifdef DL_F_CHECK_DATA_DEBUG
	checkCpAcStartInfo(legInfosCP, cpAcAssigns, cpAcStartInfos, numStartInfo, availAcs, availPilots) ;
#endif

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	generateColumns( availPilots, cpAcAssigns, cpAcStartInfos, numStartInfo, &newAssigns, &numNewAssigns ) ;
#ifdef DL_F_PRINT_DATA_DEBUG
	printNewAssigns( newAssigns, numNewAssigns, numStartInfo);
#endif
#ifdef DL_F_CHECK_DATA_DEBUG
	checkColumns(legInfosCP, cpAcAssigns, cpAcStartInfos, numStartInfo, newAssigns, numNewAssigns );
#endif

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	optDutyLineB (cpAcAssigns, cpAcStartInfos, numStartInfo, availAcs, availPilots, newAssigns, numNewAssigns, legInfosCP, crewAssignP, numCrewAssignP );	
	_ASSERTE( (*numCrewAssignP) > 0 && (*crewAssignP) != NULL );
<<<<<<< .mine
	//free( *crewAssignP );
	//*crewAssignP = NULL ;
	//*numCrewAssignP = 0 ;
=======
>>>>>>> .r29673

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	_ASSERTE( newAssigns && numNewAssigns );
	//for(i=0; i < numStartInfo ; i ++)
	//{
	//	_ASSERTE(  newAssigns[i] && numNewAssigns[i] );
	//	for(fDay=0; fDay < optParam.planningWindowDuration; fDay ++)
	//	{
	//		_ASSERTE( numNewAssigns[i][fDay] && newAssigns[i][fDay] );
	//		
	//		for(j=0; j < 2; j ++)
	//			if( newAssigns[i][fDay][j] != NULL )
	//			{
	//				_ASSERTE( numNewAssigns[i][fDay][j] > 0 );
	//				for(k=0; k < numNewAssigns[i][fDay][j]; k ++)
	//					colFree( &(newAssigns[i][fDay][j][k]) );
	//				free( newAssigns[i][fDay][j] );
	//				newAssigns[i][fDay][j] = NULL;
	//			}
	//		free( newAssigns[i][fDay] );
	//		newAssigns[i][fDay] = NULL;
	//		free( numNewAssigns[i][fDay] );
	//		numNewAssigns[i][fDay] = NULL ;
	//	}
	//	free( newAssigns[i] );
	//	newAssigns[i] = NULL;
	//	free( numNewAssigns[i] );
	//	numNewAssigns[i] = NULL ;
	//}
	//free( newAssigns );
	//newAssigns = NULL;
	free( numNewAssigns );
	numNewAssigns = NULL ;
	//end

	if( longMaint != NULL )
	{
		free( longMaint );
		longMaint = NULL ;
	}
	if( regions != NULL )
	{
		free( regions );
		regions = NULL ;
	}
	if( cpAcAssigns != NULL )
	{
		for(i=0; i < numCrewPairs; i ++ )
			if( cpAcAssigns[i] != NULL ) //current cp not assigned
			{
				free( cpAcAssigns[i] ) ;
				cpAcAssigns[i] = NULL ;
			}
		free(cpAcAssigns);
		cpAcAssigns = NULL;
	}
	if( cpAcStartInfos != NULL )
	{
		free( cpAcStartInfos ) ;
		cpAcStartInfos = NULL ;
	}
	if( legInfosCP != NULL )
	{
		free( legInfosCP );
		legInfosCP = NULL ;
	}
	if( availAcs != NULL )
	{
		free(availAcs);
		availAcs= NULL;
	}
	if( availPilots != NULL )
	{
		free(availPilots);
		availPilots = NULL;
	}
	if( dlDemUsed != NULL )
	{
		free( dlDemUsed );
		dlDemUsed = NULL ;
	}
	
	endTm = time(NULL) ;

	fprintf(dlFile, "\n\n -->total running time: %d \n", endTm-startTm);

	if( fclose(dlFile) )
	{	
		logMsg(dlFile, "can't close Duty Line File \n");
		exit(1);
	}

	return 0;
}


static int optDutyLineB (const DL_CpAcAssign **cpAcAssigns, const DL_CpAcStartInfo *cpAcStartInfos, const int numStartInfo, const DL_AvailInfo *availAcs
, const DL_AvailInfo *availPilots, DL_Column ****naP, const int ***numNAP, const DL_LegInfo *legInfosCP, ProposedCrewAssg **crewAssignP, int *numCrewAssignP)
{
	int isDropOff, numLpCols;
	int *rowStartInd=NULL, *colStartInd=NULL, *indices=NULL, *acUsed=NULL, *pilotUsed=NULL, *dColToDInd=NULL, *aColToAInd=NULL ;
	int status, i, j, k, m, day, sDay, tDay, curInd, demInd, cpInd, fixStartInd, numTotalCols ;
	CPXENVptr env = NULL;
	CPXLPptr lp = NULL;
	double *right=NULL, *coefficients=NULL, *x=NULL;
	char *sign=NULL, **rowNames=NULL, *charBuf=NULL;
	double cost;
	DL_Column *curDutyP=NULL;
	DL_LpColumn *lpCols=NULL, *curP=NULL, *pickedLpCols=NULL;
	time_t tempTm;
	
	//const time_t longRestTm =  Minute*(optParam.minRestTm + optParam.postFlightTm + optParam.preFlightTm) ;
	const time_t PostPlusRestTm =  Minute*(optParam.minRestTm + optParam.postFlightTm) ;

	const int OneK = 1024;
	const int cmatbeg = 0; //for cplex
	const int ccnt = 1;
	const double lb= 0.0;
	const double ub= 1.0;
	const char ctype = 'B' ;
	const char lu = 'L' ;
	const char uu = 'U' ;

	const double tempRHS = 5.0; //temp for dem coverage
	const double tempCO = 1000.0; //temp penalty
	const double roundToOne = 0.5 ;

	_ASSERTE( (*numCrewAssignP) > 0 && (*crewAssignP) != NULL );
	free( *crewAssignP );
	*crewAssignP = NULL ;
	*numCrewAssignP = 0 ;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////get row numbers
	if (!(rowStartInd = (int *) calloc (NumRowTypes, sizeof (int)))) //row start index for each row type
	{
		logMsg(dlFile,"%s Line %d: Out of Memory \n", __FILE__,__LINE__);
		exit(1);
	}
	if (!(colStartInd = (int *) calloc (NumColTypes, sizeof (int)))) //col start index for each col type
	{
		logMsg(dlFile,"%s Line %d: Out of Memory \n", __FILE__,__LINE__);
		exit(1);
	}
	
	rowStartInd[DL_Row_StartInfo] = 0 ; //start infos
	rowStartInd[DL_Row_StartInfo_Con] = rowStartInd[DL_Row_StartInfo] + numStartInfo;//pickup-dropoff on each day
	rowStartInd[DL_Row_StartInfo_ConTm] = rowStartInd[DL_Row_StartInfo_Con] + numStartInfo*optParam.planningWindowDuration;//pickup-dropoff time on each day
	rowStartInd[DL_Row_Pilot] = rowStartInd[DL_Row_StartInfo_ConTm] + numStartInfo*optParam.planningWindowDuration;//available pilot
	rowStartInd[DL_Row_PilotTm] = rowStartInd[DL_Row_Pilot] + numCrew ;//available pilot tm
	rowStartInd[DL_Row_Ac] = rowStartInd[DL_Row_PilotTm] + numCrew ;//available ac
	rowStartInd[DL_Row_AcTm] = rowStartInd[DL_Row_Ac] + numAircraft ;//available ac tm
	rowStartInd[DL_Row_OptDuty] = rowStartInd[DL_Row_AcTm] + numAircraft ;//opt duties
	rowStartInd[DL_Row_CrewedAc] = rowStartInd[DL_Row_OptDuty] + numCrewPairs*optParam.planningWindowDuration ;//crewed ac
	rowStartInd[DL_Row_CvdDem] = rowStartInd[DL_Row_CrewedAc] + numAircraft*optParam.planningWindowDuration ;//covered dem
	rowStartInd[DL_Row_CvdReg] = rowStartInd[DL_Row_CvdDem] + numDemand ;//covered reg
	rowStartInd[DL_Row_Total] = rowStartInd[DL_Row_CvdReg] ;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////allocate
	if (!(right = (double *) calloc (rowStartInd[DL_Row_Total], sizeof (double))))//right hand side
	{
		logMsg(dlFile,"%s Line %d: Out of Memory \n", __FILE__,__LINE__);
		exit(1);
	}
	if (!(sign = (char *) calloc (rowStartInd[DL_Row_Total], sizeof (char))))//signes
	{
		logMsg(dlFile,"%s Line %d: Out of Memory \n", __FILE__,__LINE__);
		exit(1);
	}
	if (!(coefficients = (double *) calloc (rowStartInd[DL_Row_Total], sizeof (double))))//coefficients in a column
	{
		logMsg(dlFile,"%s Line %d: Out of Memory \n", __FILE__,__LINE__);
		exit(1);
	}
	if (!(indices = (int *) calloc (rowStartInd[DL_Row_Total], sizeof (int))))//row indices in a column
	{
		logMsg(dlFile,"%s Line %d: Out of Memory \n", __FILE__,__LINE__);
		exit(1);
	}
	if ((charBuf = (char *) calloc (OneK, sizeof (char))) == NULL)//for error message
	{
		logMsg(dlFile,"%s Line %d: Out of Memory in optimizeIt().\n", __FILE__,__LINE__);
		exit(1);
	}
	if ((rowNames = (char **) calloc (rowStartInd[DL_Row_Total], sizeof (char *))) == NULL)
	{
		logMsg(dlFile,"%s Line %d: Out of Memory in optimizeIt().\n", __FILE__,__LINE__);
		exit(1);
	}
	for (i=0; i<rowStartInd[DL_Row_Total]; i++)
		if ((rowNames[i] = (char *) calloc (1024, sizeof (char))) == NULL)
		{
			logMsg(dlFile,"%s Line %d: Out of Memory in optimizeIt().\n", __FILE__,__LINE__);
			exit(1);
		}
	if ( ! (env = CPXopenCPLEX (&status)) ) 
	{
		logMsg(dlFile, "Could not open CPLEX environment.\n");
		exit(1);
	}
	if ( !(lp = CPXcreateprob (env, &status, "DL")) ) 
	{
		logMsg(dlFile, "Failed to create LP.\n");
		exit(1);
	}

/////////////////////////////////////////////////////////////////////////////////////////////////////generate empty rows: get signs and right hand side
	for (i=rowStartInd[DL_Row_StartInfo]; i<rowStartInd[DL_Row_StartInfo+1] ; i++)
	{
		k = i-rowStartInd[DL_Row_StartInfo] ;
		
		sprintf(rowNames[i], "Row_%d_StartInfo_Cover_ind_%d_%d_%d_%d", i, k, acList[cpAcStartInfos[k].acAvail.ind].aircraftID
		, crewList[cpAcStartInfos[k].pilotAvail[0].ind].crewID, crewList[cpAcStartInfos[k].pilotAvail[1].ind].crewID );

		right[i] = 1;

		if( cpAcStartInfos[k].type == DL_NewAvail ) 
			sign[i] = 'L';
		else 
			sign[i] = 'E'; //must cover opt tours
	}
	//pick up on a day
	_ASSERTE( rowStartInd[DL_Row_StartInfo_Con] + numStartInfo*optParam.planningWindowDuration == rowStartInd[DL_Row_StartInfo_Con + 1] ) ;
	k = rowStartInd[DL_Row_StartInfo_Con];//row index; initialize
	for(i=0; i < numStartInfo; i++)
		for(j=0; j < optParam.planningWindowDuration; j++)
		{
			sprintf(rowNames[k], "Row_%d_StartInfo_Con_ind_%d_day_%d_%d_%d_%d", k, i, j, acList[cpAcStartInfos[i].acAvail.ind].aircraftID
			, crewList[cpAcStartInfos[i].pilotAvail[0].ind].crewID, crewList[cpAcStartInfos[i].pilotAvail[1].ind].crewID );
			
			right[k] = 0;
			sign[k] = 'L';
			k ++;
		}
	_ASSERTE( rowStartInd[DL_Row_StartInfo_Con + 1] == k );

	//pick up time on a day
	_ASSERTE( rowStartInd[DL_Row_StartInfo_ConTm] + numStartInfo*optParam.planningWindowDuration == rowStartInd[DL_Row_StartInfo_ConTm + 1] ) ;
	k = rowStartInd[DL_Row_StartInfo_ConTm];//row index; initialize
	for(i=0; i < numStartInfo; i++)
		for(j=0; j < optParam.planningWindowDuration; j++)
		{
			sprintf(rowNames[k], "Row_%d_StartInfo_Con_Tm_ind_%d_day_%d_%d_%d_%d", k, i, j, acList[cpAcStartInfos[i].acAvail.ind].aircraftID
			, crewList[cpAcStartInfos[i].pilotAvail[0].ind].crewID, crewList[cpAcStartInfos[i].pilotAvail[1].ind].crewID );
			
			right[k] = 0;
			sign[k] = 'L';
			k ++;
		}
	_ASSERTE( rowStartInd[DL_Row_StartInfo_ConTm + 1] == k );

	for (i=rowStartInd[DL_Row_Pilot]; i<rowStartInd[DL_Row_Pilot+1] ; i++)//available pilots
	{
		sprintf( rowNames[i], "Row_%d_Available_Pilots_ID_%d", i, crewList[i-rowStartInd[DL_Row_Pilot]].crewID );
		right[i] = 1;
		sign[i] = 'L';
	}
	for (i=rowStartInd[DL_Row_PilotTm]; i<rowStartInd[DL_Row_PilotTm+1] ; i++)//pilot pick up time
	{
		sprintf( rowNames[i], "Row_%d_Available_Pilots_Time_ID_%d", i, crewList[i-rowStartInd[DL_Row_PilotTm]].crewID );
		right[i] = 0;
		sign[i] = 'L';
	}
	for (i=rowStartInd[DL_Row_Ac]; i<rowStartInd[DL_Row_Ac+1] ; i++)//available acs
	{
		sprintf( rowNames[i], "Row_%d_Available_Aircrafts_ID_%d", i, acList[i-rowStartInd[DL_Row_Ac]].aircraftID);
		right[i] = 1;
		sign[i] = 'L';
	}
	for (i=rowStartInd[DL_Row_AcTm]; i<rowStartInd[DL_Row_AcTm+1] ; i++)//ac pick up time
	{
		sprintf( rowNames[i], "Row_%d_Available_Aircrafts_Time_ID_%d", i, acList[i-rowStartInd[DL_Row_AcTm]].aircraftID);
		right[i] = 0;
		sign[i] = 'L';
	}
	//cover opt duties
	k = rowStartInd[DL_Row_OptDuty];//row index; initialize
	for(i=0; i < numCrewPairs; i++)
		for(j=0; j < optParam.planningWindowDuration; j++)
		{
			sprintf( rowNames[k], "Row_%d_Opt_Duty_CP_%d_Day_%d", k, i, j);
			sign[k] = 'E';
			if( cpAcAssigns[i] && cpAcAssigns[i][j].numAc )
				right[k] = 1;
			else
				right[k] = 0;
			k ++ ;
		}
	//crewed ac
	k = rowStartInd[DL_Row_CrewedAc];//row index; initialize
	for(i=0; i < numAircraft; i++)
		for(j=0; j < optParam.planningWindowDuration; j++)
		{
			sprintf( rowNames[k], "Row_%d_Crew_Ac_%d_Day_%d", k, acList[i].aircraftID, j);
			right[k] = 1;
			sign[k] = 'G';
			k ++ ;
		}
	for (i=rowStartInd[DL_Row_CvdDem]; i<rowStartInd[DL_Row_CvdDem+1] ; i++)//covered dem
	{
		j = i-rowStartInd[DL_Row_CvdDem] ;
		sprintf( rowNames[i], "Row_%d_Demand_Covering_ID_%d", i, demandList[j].demandID);
		sign[i] = 'G';
		if( demandList[j].isAppoint || demandList[j].outAirportID == demandList[j].inAirportID )//not regular demand, not to cover
			right[i] = 0 ;
		else
			right[i] = tempRHS ;
	}
	if (status = CPXnewrows (env, lp, rowStartInd[DL_Row_Total], right, sign, NULL, rowNames))//build empty rows
	{
		logMsg(dlFile, "CPLEX failed to create rows.\n");
		CPXgeterrorstring (env, status, charBuf);
		logMsg(dlFile,"%s", charBuf);
		exit(1);
	}

////////////////////////////////////////////////////////////////////////////////////////////////////add all columns
	numTotalCols = 0 ;
	numLpCols = 0 ;
	colStartInd[DL_Col_LP] = 0 ;//start index for each type of columns
	for(i=0; i < numStartInfo ; i ++)
	{
		_ASSERTE( naP[i] && numNAP[i] );//allocated

		for( day=0; day < optParam.planningWindowDuration; day ++ )//check each possible day to start
		{
			_ASSERTE( naP[i][day] && numNAP[i][day] );//allocated

			for( k=0; k<2; k++ ) //two types: k=0 --> first duty
			{
				if( !numNAP[i][day][k] )
					continue;

				_ASSERTE( naP[i][day][k] && numNAP[i][day][k] > 0 );

				for(j=0; j <numNAP[i][day][k]; j ++)//for each duty
				{
					curInd = 0; //for adding col to LP; initialize

					curDutyP = &(naP[i][day][k][j]) ;
					cpInd = curDutyP->startInfoP->cpInd ;
					cost = curDutyP->cost ;

					sprintf (charBuf, "Duty_Column_%d_StartInfo_%d_Day_%d_FirstDay_%d_%d_%d_%d", numTotalCols, i, day, curDutyP->firstDay
					, acList[curDutyP->acInd].aircraftID, crewList[curDutyP->startInfoP->pilotAvail[0].ind].crewID, crewList[curDutyP->startInfoP->pilotAvail[1].ind].crewID);	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////add dems covered by current duty
					for(m=0; m<curDutyP->numCoverDems; m++)
					{
						_ASSERTE( curDutyP->coverDems[m] >= 0 && curDutyP->coverDems[m] < numDemand );
						indices[curInd] = rowStartInd[DL_Row_CvdDem] + curDutyP->coverDems[m];//row index
						coefficients[curInd] = 1;
						curInd ++;
					}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////add opt duty covered by current duty
					if( curDutyP->cpAcAssignP )
					{
						_ASSERTE( curDutyP->startInfoP->type != DL_NewAvail && cpAcAssigns[cpInd] && cpAcAssigns[cpInd][day].numAc
						&& curDutyP->cpAcAssignP == &(cpAcAssigns[cpInd][day]) );

						indices[curInd] = rowStartInd[DL_Row_OptDuty] + cpInd*optParam.planningWindowDuration + day;//row index
						coefficients[curInd] = 1;
						curInd ++;
					}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////add ac crewed by current duty
					if( !curDutyP->cpAcAssignP )
					{
						indices[curInd] = rowStartInd[DL_Row_CrewedAc] + curDutyP->acInd*optParam.planningWindowDuration + day;//row index
						coefficients[curInd] = 1;
						curInd ++;
					} else
					{
						_ASSERTE( curDutyP->cpAcAssignP->numAc && curDutyP->cpAcAssignP->acInd[0] == curDutyP->acInd );
						for(m=0; m<curDutyP->cpAcAssignP->numAc; m++)
						{
							_ASSERTE( curDutyP->cpAcAssignP->acInd[m] >= 0 );
							indices[curInd] = rowStartInd[DL_Row_CrewedAc] + curDutyP->cpAcAssignP->acInd[m]*optParam.planningWindowDuration + day;//row index
							coefficients[curInd] = 1;
							curInd ++;
						}//end for(m=0; m<DL_MAX_NUM_AC_PER_DUTY; m++)
					}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////add pick up
					if( !k )//first duty of a startInfo, add startInfo index and pick up from available acs and pilots
					{
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////add startInfo
						indices[curInd] = rowStartInd[DL_Row_StartInfo] + curDutyP->startInfoP->index;
						coefficients[curInd] = 1;
						curInd ++;
/////////////////////////////////////////////////////////////////////////////////////////////////////////////not an opt tour, pick up from avail ac/pilot
						//no pickup for opt tours
						//pick up for the firs ac of the duty
						if( curDutyP->startInfoP->type == DL_NewAvail )
						{
							_ASSERTE( !cpAcAssigns[cpInd] || (curDutyP->startInfoP->pilotAvail[0].availAfter == DL_AfterLeg 
							&& curDutyP->startInfoP->pilotAvail[1].availAfter == DL_AfterLeg));

							for(m=0; m<2; m++)//each pilot
							{
								_ASSERTE( availPilots[curDutyP->startInfoP->pilotAvail[m].ind].availAfter );//pilot available

								indices[curInd] = rowStartInd[DL_Row_Pilot] + curDutyP->startInfoP->pilotAvail[m].ind;//pick up from available pilots
								coefficients[curInd] = 1;
								curInd ++;

								if( availPilots[curDutyP->startInfoP->pilotAvail[m].ind].availAfter == DL_AfterLeg )//consider time, only if pilot available afrer opt tours
								{
									_ASSERTE( optParam.windowEnd - curDutyP->pilotStartTm[m] + PostPlusRestTm  >= 0 );
									indices[curInd] = rowStartInd[DL_Row_PilotTm] + curDutyP->startInfoP->pilotAvail[m].ind;
									coefficients[curInd] = ceil((double)(optParam.windowEnd - curDutyP->pilotStartTm[m] + PostPlusRestTm )/(double)DiscrtLPInterval);
									curInd ++;
								}
							}

							indices[curInd] = rowStartInd[DL_Row_Ac] + curDutyP->acInd;//pick up ac; first ac
							coefficients[curInd] = 1;
							curInd ++;

							if( availAcs[curDutyP->acInd].availAfter == DL_AfterLeg )//consider time, only if ac available afrer opt tours
							{
								_ASSERTE( optParam.windowEnd - curDutyP->startTm + Minute*optParam.turnTime >= 0 );
								indices[curInd] = rowStartInd[DL_Row_AcTm] + curDutyP->acInd;
								coefficients[curInd] = ceil((double)(optParam.windowEnd - curDutyP->startTm + Minute*optParam.turnTime)/(double)DiscrtLPInterval );
								curInd ++;
							}
						}//end if( curDutyP->startInfoP->type == DL_NewAvail )
					} else //not first duty, pick up from prev duty
					{
						//pick up from previous duty
						indices[curInd] = rowStartInd[DL_Row_StartInfo_Con] + (curDutyP->startInfoP->index*optParam.planningWindowDuration) + day;
						coefficients[curInd] = 1;
						curInd ++;

						//need to consider pick up time in the following cases
						if( curDutyP->startInfoP->type == DL_NewAvail //new tour
						|| !curDutyP->cpAcAssignP //opt tour, but no legs on current day
						|| (!curDutyP->keepOriginal && curDutyP->cpAcAssignP->tmFixed != DL_StartTmFixed ))//duty fixed or start time is fixed
						{
							tempTm = min(curDutyP->pilotStartTm[0], curDutyP->pilotStartTm[1]) ;

							_ASSERTE( ( curDutyP->day <= curDutyP->startInfoP->legStartDay || curDutyP->pilotStartTm[0] == curDutyP->pilotStartTm[1])  
							&&  curDutyP->startInfoP->acCpDay < day && optParam.windowEnd - tempTm + PostPlusRestTm >= 0 );

							indices[curInd] = rowStartInd[DL_Row_StartInfo_ConTm] + (curDutyP->startInfoP->index*optParam.planningWindowDuration) + day;
							coefficients[curInd] = ceil((double)(optParam.windowEnd - tempTm + PostPlusRestTm)/(double)DiscrtLPInterval );
							curInd ++;
						}
					}//end if( !k )

/////////////////////////////////////////////////////////////////////////////may have several dropoff options, and need to generate more than one columns
					fixStartInd = curInd ; //entries before curInd are the same in these columns; initialize
					isDropOff = 0; //whether there is dropoff to the next duty/tour, i.e. whether any columns are added
					_ASSERTE( day <= curDutyP->startInfoP->lastPossibleDay && curDutyP->startInfoP->lastPossibleDay < optParam.planningWindowDuration );
					//get sDay; must dropoff to days [day+1, sDay]
					if( cpAcAssigns[cpInd] )
					{
						for( sDay = day+1; sDay <= curDutyP->startInfoP->lastPossibleDay; sDay ++ )
							if( cpAcAssigns[cpInd][sDay].numAc )
								break;
					} else
						sDay = curDutyP->startInfoP->lastPossibleDay + 1;
					
					_ASSERTE( sDay <= optParam.planningWindowDuration );

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////drop off to the next startInfo
					//if sDay <= curDutyP->startInfoP->lastPossibleDay, then there is a duty containing legs on day sDay, can't dropoff to the next tour
					if( curDutyP->startInfoP->type != DL_NewAvail && sDay > curDutyP->startInfoP->lastPossibleDay ) 
					{
						curInd = fixStartInd ;//initialize

						for(m=0; m<2; m++)//drop off pilots
							if( availPilots[curDutyP->startInfoP->pilotAvail[m].ind].availAfter )//pilot is set to be available, drop off (consider only time)
							{
								_ASSERTE ( optParam.windowEnd >= curDutyP->endTm ) ;
								indices[curInd] = rowStartInd[DL_Row_PilotTm] + curDutyP->startInfoP->pilotAvail[m].ind;
								coefficients[curInd] = -floor((double)(optParam.windowEnd - curDutyP->endTm)/(double)DiscrtLPInterval );
								curInd ++;
							}

						//ac to drop off
						m = ( curDutyP->cpAcAssignP ? curDutyP->cpAcAssignP->acInd[curDutyP->cpAcAssignP->numAc-1] : curDutyP->acInd );
						if( availAcs[m].availAfter )//ac is set to be available(consider only time)
						{
							_ASSERTE ( optParam.windowEnd >= curDutyP->endTm ) ;
							indices[curInd] = rowStartInd[DL_Row_AcTm] + m;
							coefficients[curInd] = -floor((double)(optParam.windowEnd - curDutyP->endTm)/(double)DiscrtLPInterval ) ;
							curInd ++;
						}

						//if dropoff, add columns
						if ( curInd > fixStartInd )
						{
							isDropOff = 1;
#ifdef DL_F_LP_COL_CHECK_DEBUG
							if (status = CPXcheckaddcols(env, lp, ccnt, curInd, &cost, &cmatbeg, indices, coefficients, &lb, NULL, &charBuf))
#else
							if (status = CPXaddcols(env, lp, ccnt, curInd, &cost, &cmatbeg, indices, coefficients, &lb, NULL, &charBuf ))
#endif
							{
								logMsg(dlFile, "CPLEX failed to create column.\n");
								CPXgeterrorstring (env, status, charBuf);
								logMsg(dlFile,"%s", charBuf);
								exit(1);
							}
							//generate the corresponding lp column
							curP = allocAnLpColumn( &lpCols, &numLpCols);
							curP->col = curDutyP ;
							curP->dropOff = 1;
							curP->nextDay = -1;
							curP->fDuty = ( k ? 0 : 1 ) ;

							numTotalCols ++;
						}//end if ( curInd > fixStartInd )
					}//if( sDay > curDutyP->startInfoP->lastPossibleDay )

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////drop off to the next duty on tDay
					//dropoff to days in [day+1, sDay] of the same tour
					for( tDay = day + 1; tDay <= min(sDay, optParam.planningWindowDuration-1) ; tDay ++)
					{
						isDropOff = 1;
						curInd = fixStartInd ;

						//connect on the next day
						indices[curInd] = rowStartInd[DL_Row_StartInfo_Con] + (curDutyP->startInfoP->index*optParam.planningWindowDuration) + tDay;
						coefficients[curInd] = -1;
						curInd ++;

						//time on the next day
						_ASSERTE ( optParam.windowEnd >= curDutyP->endTm ) ;
						indices[curInd] = rowStartInd[DL_Row_StartInfo_ConTm] + (curDutyP->startInfoP->index*optParam.planningWindowDuration) + tDay;
						coefficients[curInd] = -floor((double)(optParam.windowEnd - curDutyP->endTm)/(double)DiscrtLPInterval );
						curInd ++;

#ifdef DL_F_LP_COL_CHECK_DEBUG
						if (status = CPXcheckaddcols(env, lp, ccnt, curInd, &cost, &cmatbeg, indices, coefficients, &lb, NULL, &charBuf))
#else
						if (status = CPXaddcols(env, lp, ccnt, curInd, &cost, &cmatbeg, indices, coefficients, &lb, NULL, &charBuf))
#endif
						{
							logMsg(dlFile, "CPLEX failed to create column.\n");
							CPXgeterrorstring (env, status, charBuf);
							logMsg(dlFile,"%s", charBuf);
							exit(1);
						}
						//generate the corresponding lp column
						curP = allocAnLpColumn( &lpCols, &numLpCols);
						curP->col = curDutyP ;
						curP->dropOff = 0;
						curP->nextDay = tDay;
						curP->fDuty = ( k ? 0 : 1 ) ;

						numTotalCols ++;
					}//end for( tDay = day + 1; tDay < sDay; tDay ++)

					if( !isDropOff )//no columns generated so far for this duty; no drop off; add the original column
					{
						_ASSERTE( curInd == fixStartInd );
#ifdef DL_F_LP_COL_CHECK_DEBUG
						if (status = CPXcheckaddcols(env, lp, ccnt, curInd, &cost, &cmatbeg, indices, coefficients, &lb, NULL, &charBuf))
#else
						if (status = CPXaddcols(env, lp, ccnt, curInd, &cost, &cmatbeg, indices, coefficients, &lb, NULL, &charBuf))
#endif
						{
							logMsg(dlFile, "CPLEX failed to create column.\n");
							CPXgeterrorstring (env, status, charBuf);
							logMsg(dlFile,"%s", charBuf);
							exit(1);
						}
						curP = allocAnLpColumn( &lpCols, &numLpCols);
						curP->col = curDutyP ;
						curP->dropOff = 0;
						curP->nextDay = -1;
						curP->fDuty = ( k ? 0 : 1 ) ;

						numTotalCols ++;
					}//if( !isDropOff )

				}//end for(j=0; j <numNAP[i][day][k]; j ++)
			}//end for( k=0; k<2; k++ )
		}//for( day=0; day < optParam.planningWindowDuration; day ++ )
	}//end for(i=0; i < numStartInfo ; i ++)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////add dem cover columns
	colStartInd[DL_Col_Dem]  = numTotalCols ;
	if (!(dColToDInd = (int *) calloc (numDemand, sizeof (int)))) //demand index of each demand column; only to-be-covered demands are added to the columns
	{
		logMsg(dlFile,"%s Line %d: Out of Memory \n", __FILE__,__LINE__);
		exit(1);
	}
	for( demInd=0; demInd<numDemand; demInd++)//generate dem columns
	{
		if( demandList[demInd].isAppoint || demandList[demInd].outAirportID == demandList[demInd].inAirportID )
			continue ;

		sprintf (charBuf, "Demand_Covering_Column_%d_ID_%d", numTotalCols, i, demandList[demInd].demandID);	

		indices[0] = rowStartInd[DL_Row_CvdDem] + demInd;//row index
		coefficients[0] = tempRHS; //temp
		curInd = 1;
		
#ifdef DL_F_LP_COL_CHECK_DEBUG
		if (status = CPXcheckaddcols(env, lp, ccnt, curInd, &tempCO, &cmatbeg, indices, coefficients, &lb, &ub, &charBuf))
#else
		if (status = CPXaddcols(env, lp, ccnt, curInd, &tempCO, &cmatbeg, indices, coefficients, &lb, &ub, &charBuf))
#endif
		{
			logMsg(dlFile, "CPLEX failed to create dem column.\n");
			CPXgeterrorstring (env, status, charBuf);
			logMsg(dlFile,"%s", charBuf);
			exit(1);
		}
		dColToDInd[numTotalCols-colStartInd[DL_Col_Dem]] = demInd ;//keep demand index
		_ASSERTE( numTotalCols-colStartInd[DL_Col_Dem] < numDemand );
		numTotalCols ++;
	}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////add ac cover columns
	colStartInd[DL_Col_Ac]  = numTotalCols ;
	if (!(aColToAInd = (int *) calloc (numAircraft*optParam.planningWindowDuration, sizeof (int)))) //temp
	{
		logMsg(dlFile,"%s Line %d: Out of Memory \n", __FILE__,__LINE__);
		exit(1);
	}
	k = 0 ;//index //initialize
	for( i=0; i<numAircraft; i++)//generate ac columns
	{
		for(j=0; j < optParam.planningWindowDuration; j ++ )
		{
			//if( !availAcs[i].availAfter )
			//	continue;

			sprintf (charBuf, "Aircraft_Crewing_Column_%d_ID_%d_Day_%d", numTotalCols, acList[i].aircraftID, j);	

			indices[0] = rowStartInd[DL_Row_CrewedAc] + i*optParam.planningWindowDuration + j ;//row index
			coefficients[0] = 1;
			curInd = 1;

#ifdef DL_F_LP_COL_CHECK_DEBUG
			if (status = CPXcheckaddcols(env, lp, ccnt, curInd, &tempCO, &cmatbeg, indices, coefficients, &lb, &ub, &charBuf))
#else
			if (status = CPXaddcols(env, lp, ccnt, curInd, &tempCO, &cmatbeg, indices, coefficients, &lb, &ub, &charBuf))
#endif
			{
				logMsg(dlFile, "CPLEX failed to create dem column.\n");
				CPXgeterrorstring (env, status, charBuf);
				logMsg(dlFile,"%s", charBuf);
				exit(1);
			}
			aColToAInd[k] = i ;//keep ac ind
			numTotalCols ++;
			k ++ ;
		}
	}
	colStartInd[DL_Col_Ac+1] = numTotalCols ;
	_ASSERTE( numTotalCols > 0 && numTotalCols == CPXgetnumcols (env, lp) );

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////solve
	for(i=0; i < numLpCols; i++)//set binary varaible
	{
		if ( status = CPXchgctype (env, lp, ccnt, &i, &ctype) ) 
		{
			fprintf (stderr, "Failed to copy ctype\n");
			CPXgeterrorstring (env, status, charBuf);
			logMsg(dlFile,"%s", charBuf);
			exit(1);
		}

		if ( status = CPXchgbds (env, lp, ccnt, &i, &lu, &lb) ) 
		{
			fprintf (stderr, "Failed to copy lb\n");
			CPXgeterrorstring (env, status, charBuf);
			logMsg(dlFile,"%s", charBuf);
			exit(1);
		}

		if ( status = CPXchgbds (env, lp, ccnt, &i, &uu, &ub) ) 
		{
			fprintf (stderr, "Failed to copy lb\n");
			CPXgeterrorstring (env, status, charBuf);
			logMsg(dlFile,"%s", charBuf);
			exit(1);
		}
	}

	CPXsetintparam (env, CPX_PARAM_SCRIND, 1);

#ifdef DL_F_LP_WRITE_DEBUG
	if(status = CPXwriteprob(env, lp, "./Logfiles/DL_LP.lp", NULL))
	{
		fprintf (stderr, "Failed to write the problem \n");
		CPXgeterrorstring (env, status, charBuf);
		logMsg(dlFile,"%s", charBuf);
		exit(1);
	}
#endif

	if (status = CPXmipopt (env, lp)) 
	{
		logMsg(dlFile, "Failed to optimize MIP.\n");
		CPXgeterrorstring (env, status, charBuf);
		logMsg(dlFile,"%s", charBuf);
		exit(1);
	}	

	if ( status = CPXgetobjval (env, lp, &cost) ) 
	{
		logMsg(dlFile, "Failed to get objective function value.\n");
		CPXgeterrorstring (env, status, charBuf);
		logMsg(dlFile,"%s", charBuf);
		exit(1);
	}
	printf("\n obj = %f \n", cost );

#ifdef DL_F_SOLUTION_DEBUG
	printAndCheckSolution ( env, lp, cpAcStartInfos, numStartInfo, availAcs, availPilots, colStartInd, dColToDInd, aColToAInd, lpCols, legInfosCP, cpAcAssigns
	, crewAssignP, numCrewAssignP );
#endif

	if( rowNames != NULL )
	{
		for (i=0; i<rowStartInd[DL_Row_Total]; i++)
		{	
			free( rowNames[i] );
			rowNames[i] = NULL;
		}
		free( rowNames );
		rowNames = NULL ;
	}

	if( rowStartInd != NULL )
	{
		free( rowStartInd );
		rowStartInd = NULL;
	}
	if( indices != NULL )
	{
		free( indices );
		indices = NULL;
	}
	if( right != NULL )
	{
		free( right );
		right = NULL;
	}
	if( coefficients != NULL )
	{
		free( coefficients );
		coefficients = NULL;
	}
	if( x != NULL )
	{
		free( x );
		x = NULL;
	}
	if( sign != NULL )
	{
		free( sign );
		sign = NULL;
	}
	if( charBuf != NULL )
	{
		free( charBuf );
		charBuf = NULL ;
	}
	if( lpCols != NULL )
	{
		free(lpCols);
		lpCols = NULL;
	}
	if ( lp != NULL && (status = CPXfreeprob (env, &lp))) 
	{
		logMsg ( dlFile, "CPXfreeprob failed, error code %d.\n", status);
		exit(1);
	}
	if ( env != NULL && (status = CPXcloseCPLEX (&env)) )
	{
		logMsg ( dlFile, "CPXcloseCPLEX failed, error code %d.\n", status);
		exit(1);
	}
	if( dColToDInd != NULL )
	{
		free(dColToDInd);
		dColToDInd = NULL;
	}
	if( aColToAInd != NULL )
	{
		free(aColToAInd);
		aColToAInd = NULL;
	}
	
	return 0;
}

static int printAndCheckSolution ( const CPXENVptr env, const CPXLPptr lp, const DL_CpAcStartInfo *cpAcStartInfos, const int numStartInfo, const DL_AvailInfo *availAcs
, const DL_AvailInfo *availPilots, const int *colStartInd, const int *dColToDInd, const int *aColToAInd, const DL_LpColumn *lpCols, const DL_LegInfo *legInfosCP
, const DL_CpAcAssign **cpAcAssigns, ProposedCrewAssg **crewAssignP, int *numCrewAssignP )
{
	int numLpCols;
	int **acUsed=NULL, *pilotUsed=NULL, *caToOptCol=NULL ;
	int status, i, j, k, m, n, cpInd, numTotalCols, numPickedLpCols ;
	double *x=NULL;
	char charBuf[1024] ;
	char opbuf1[1024], opbuf2[1024], opbuf3[1024], opbuf4[1024], opbuf5[1024], opbuf6[1024], opbuf7[1024];
	double tCost, oTravelCost, nTravelCost, demPen, acPen;
	DL_Column *curDutyP=NULL;
	DL_LpColumn *pickedLpCols=NULL;
<<<<<<< .mine
	const double tempCO = 1000.0; //temp for dem coverage
	const double roundToOne = 0.5 ;
	

=======
	time_t tempTm;
>>>>>>> .r29673
	//ProposedCrewAssg *dlCrewAssigns=NULL;
	//int numDlCrewAssigns = 0;

	const double tempCO = 1000.0; //temp for dem coverage
	const double roundToOne = 0.5 ;
	
	numLpCols = colStartInd[DL_Col_Dem] - colStartInd[DL_Col_LP] ;
	numTotalCols = colStartInd[DL_Col_Total] ;
	_ASSERTE( numTotalCols == CPXgetnumcols (env, lp) );

	//solution
	if ( !(x = (double *) calloc (numTotalCols, sizeof (double))))
	{
		logMsg(dlFile,"%s Line %d: Out of Memory \n", __FILE__,__LINE__);
		exit(1);
	}	
	//get solution
	if ( status = CPXgetmipx (env, lp, x, 0, numTotalCols-1) ) 
	{
		logMsg(dlFile, "Failed to recover optimal solution.\n");
		CPXgeterrorstring (env, status, charBuf);
		logMsg(dlFile,"%s", charBuf);
		exit(1);
	}
	//get columns picked in opt solution
	numPickedLpCols = 0;
	_ASSERTE( colStartInd[DL_Col_LP] == 0 );
	for(i=0; i < numLpCols; i++)
		if( x[i] >= roundToOne )
			numPickedLpCols ++;
	_ASSERTE( numPickedLpCols );
	//generate opt columns and sort
	if ( !(pickedLpCols = (DL_LpColumn *) calloc (numPickedLpCols, sizeof (DL_LpColumn))))
	{
		logMsg(dlFile,"%s Line %d: Out of Memory \n", __FILE__,__LINE__);
		exit(1);
	}
	m=0;
	for(i=0; i < numLpCols; i++)
		if( x[i] >= roundToOne )
		{
			memmove( &(pickedLpCols[m]), &(lpCols[i]), sizeof(DL_LpColumn));
			m ++;
		}
	_ASSERTE(m == numPickedLpCols);
	qsort((void *) pickedLpCols, numPickedLpCols, sizeof(DL_LpColumn ), compareLpColumn);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////print to DL file

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////print duties with more than one acs
	fprintf (dlFile, "\n\n --> Uncovered opt duties :\n");
	for(i=0; i < numCrewPairs; i++)
	{
		if( !cpAcAssigns[i] )
			continue;

		for(j=0; j < optParam.planningWindowDuration; j++)
		{
			if( !cpAcAssigns[i][j].numAc )
				continue;
			
			m = 0;
			for(k=0; k < numPickedLpCols; k++)
				if( pickedLpCols[k].col->cpAcAssignP && pickedLpCols[k].col->cpAcAssignP == &(cpAcAssigns[i][j]) )
					m ++;

			if( !m )
				fprintf(dlFile, " Opt duty with cp %d day %d not covered \n", i, j );
		}
	}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////print duties with more than one acs
	fprintf (dlFile, "\n\n --> Duty with more than one aircrafts :\n");
	for(i=0; i < numPickedLpCols; i++)
	{
		curDutyP = pickedLpCols[i].col ;
		if( curDutyP->cpAcAssignP && curDutyP->cpAcAssignP->numAc > 1 )
		{
			fprintf(dlFile, " Opt column %d contains %d aircrafts: ", i, curDutyP->cpAcAssignP->numAc );
			for(j=0; j < curDutyP->cpAcAssignP->numAc; j ++)
				fprintf(dlFile, " %d ; ", acList[curDutyP->cpAcAssignP->acInd[j]].aircraftID );
			fprintf(dlFile, " \n" );
		}
	}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////print soln
	fprintf (dlFile, "\n\n --> Solution :\n");
	j = -1 ; //current tour index
	for(i=0; i < numPickedLpCols; i++)
	{
		curDutyP = pickedLpCols[i].col ;

		if( j == -1 || curDutyP->startInfoP->index != j )
		{
			fprintf (dlFile, "+------------+------------+------------+------------+------------+------------+------------------+------------+------------------+------------+------------------+------------------+------------------+------------------+------------------+------------+------------+------------+------------+------------+------------+ \n");
			fprintf (dlFile, "| Day        | First Day  | Keep Orig  | Crew Pair  | Aircraft   | Ac Airport | Ac Avail Tm      | P0 Airport | P0 Avail Tm      | P1 Airport | P1 Avail Tm      | P0 Start Time    | P1 Start Time    | Start Time       | End Time         | Cost       | # Cvd Dems | Is First   | Drop off   | Next Day   | Has Legs   | \n");
			fprintf (dlFile, "+------------+------------+------------+------------+------------+------------+------------------+------------+------------------+------------+------------------+------------------+------------------+------------------+------------------+------------+------------+------------+------------+------------+------------+ \n");
		}

		fprintf (dlFile, "| %10d | %10d | %10d | %10d | %10d | %10d | %16s | %10d | %16s | %10d | %16s | %16s | %16s | %16s | %16s | %10.2f | %10d | %10d | %10d | %10d | %10d | \n"
		, curDutyP->day, curDutyP->firstDay, curDutyP->keepOriginal, curDutyP->startInfoP->cpInd, acList[curDutyP->startInfoP->acAvail.ind].aircraftID
		, curDutyP->acAirport
		, ( !curDutyP->acTm ? " " : dt_DateTimeToDateTimeString(dt_time_tToDateTime (curDutyP->acTm), opbuf1, "%Y/%m/%d %H:%M"))
		, curDutyP->pAirports[0]
		, ( !curDutyP->pTm[0] ? " " : dt_DateTimeToDateTimeString(dt_time_tToDateTime (curDutyP->pTm[0]), opbuf2, "%Y/%m/%d %H:%M"))
		, curDutyP->pAirports[1]
		, ( !curDutyP->pTm[1] ? " " : dt_DateTimeToDateTimeString(dt_time_tToDateTime (curDutyP->pTm[1]), opbuf3, "%Y/%m/%d %H:%M"))
		, ( !curDutyP->pilotStartTm[0] ? " " : dt_DateTimeToDateTimeString(dt_time_tToDateTime (curDutyP->pilotStartTm[0]), opbuf4, "%Y/%m/%d %H:%M"))
		, ( !curDutyP->pilotStartTm[1] ? " " : dt_DateTimeToDateTimeString(dt_time_tToDateTime (curDutyP->pilotStartTm[1]), opbuf5, "%Y/%m/%d %H:%M"))
		, ( !curDutyP->startTm ? " " : dt_DateTimeToDateTimeString(dt_time_tToDateTime (curDutyP->startTm), opbuf6, "%Y/%m/%d %H:%M"))
		, ( !curDutyP->endTm ? " " : dt_DateTimeToDateTimeString(dt_time_tToDateTime (curDutyP->endTm), opbuf7, "%Y/%m/%d %H:%M"))
		, curDutyP->cost, curDutyP->numCoverDems, pickedLpCols[i].fDuty, pickedLpCols[i].dropOff, pickedLpCols[i].nextDay
		, ( curDutyP->cpAcAssignP ? 1 : 0 ) ) ;

		fprintf (dlFile, "+------------+------------+------------+------------+------------+------------+------------------+------------+------------------+------------+------------------+------------------+------------------+------------------+------------------+------------+------------+------------+------------+------------+------------+ \n");

		j = curDutyP->startInfoP->index ;
	}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////print soln in less fields
	fprintf (dlFile, "\n\n --> Solution (simple) :\n");
	fprintf (dlFile, "+------------+------------+------------+------------+------------+------------+------------+------------+------------------+------------------+------------------+------------------+------------+ \n");
	fprintf (dlFile, "| Index      | Aircraft   | P0         | P1         | FirstDuty? | Day        | Next Day   | Drop Off?  | Start Time       | End Time         | Orig Start Time  | Orig End Time    | Tour Index | \n");
	fprintf (dlFile, "+------------+------------+------------+------------+------------+------------+------------+------------+------------------+------------------+------------------+------------------+------------+ \n");

	for(i=0; i < numPickedLpCols; i++)
	{
		curDutyP = pickedLpCols[i].col ;
		cpInd = curDutyP->startInfoP->cpInd ;

		fprintf (dlFile, "| %10d | %10d | %10d | %10d | %10d | %10d | %10d | %10d | %16s | %16s | %16s | %16s | %10d | \n"
		, i , acList[curDutyP->acInd].aircraftID, crewPairList[cpInd].captainID, crewPairList[cpInd].flightOffID, pickedLpCols[i].fDuty, curDutyP->day
		, pickedLpCols[i].nextDay, pickedLpCols[i].dropOff
		, ( !curDutyP->startTm ? " " : dt_DateTimeToDateTimeString(dt_time_tToDateTime (curDutyP->startTm), opbuf1, "%Y/%m/%d %H:%M"))
		, ( !curDutyP->endTm ? " " : dt_DateTimeToDateTimeString(dt_time_tToDateTime (curDutyP->endTm), opbuf2, "%Y/%m/%d %H:%M"))
		, ( !curDutyP->cpAcAssignP ? " " : dt_DateTimeToDateTimeString(dt_time_tToDateTime (curDutyP->cpAcAssignP->firstLegP->leg->schedOut), opbuf3, "%Y/%m/%d %H:%M"))
		, ( !curDutyP->cpAcAssignP ? " " : dt_DateTimeToDateTimeString(dt_time_tToDateTime (curDutyP->cpAcAssignP->lastLegP->leg->schedIn), opbuf4, "%Y/%m/%d %H:%M")) 
		, curDutyP->startInfoP->index);

		if( i == numPickedLpCols - 1 || pickedLpCols[i].col->acInd != pickedLpCols[i+1].col->acInd || pickedLpCols[i].col->startInfoP->cpInd != pickedLpCols[i+1].col->startInfoP->cpInd )
			fprintf (dlFile, "+------------+------------+------------+------------+------------+------------+------------+------------+------------------+------------------+------------------+------------------+------------+ \n");
	}

////////////////////////////////////////////////////////////////////////////////////////////////////////////for each demand, print columns covering it
	fprintf (dlFile, "\n\n --> To-be-covered-demands and covering columns, divided by fleet type : \n\n");
	for(j=colStartInd[DL_Col_Dem]; j < colStartInd[DL_Col_Dem+1]; j++)
	{
		fprintf (dlFile, "Demand %d covered in column :", demandList[dColToDInd[j-colStartInd[DL_Col_Dem]]].demandID );
		n = -1 ; //which col contains this demand
		for(i=0; i < numPickedLpCols; i++)
		{
			if( pickedLpCols[i].col->cpAcAssignP )
			{
				for(m=pickedLpCols[i].col->cpAcAssignP->firstLegP->legIndCP; m <= pickedLpCols[i].col->cpAcAssignP->lastLegP->legIndCP; m ++ )
					if( legInfosCP[m].leg->demandID == demandList[dColToDInd[j-colStartInd[DL_Col_Dem]]].demandID )
					{
						n = i ;
						break;
					}
			}

			for(k=0; k<pickedLpCols[i].col->numCoverDems; k++)
				if( pickedLpCols[i].col->coverDems[k] == dColToDInd[j-colStartInd[DL_Col_Dem]] )
					fprintf (dlFile, "%d ; ", i );
		}
		fprintf (dlFile, " \n");

		fprintf (dlFile, "--> with deficit : %.2f \n", x[j] );

		//_ASSERTE( n >= 0 || !dlDemUsed[dColToDInd[j-colStartInd[DL_Col_Dem]] );
		if( n >= 0)
			fprintf (dlFile, "--> contained in column : %d \n ", n );
	}

////////////////////////////////////////////////////////////////////////////////////////////////////////////for each ac, print columns containing it
	if (!(acUsed = (int **) calloc (numAircraft, sizeof (int*))))//ac used in a column in the solution
	{
		logMsg(dlFile,"%s Line %d: Out of Memory \n", __FILE__,__LINE__);
		exit(1);
	}
	for(i=0; i<numAircraft; i ++)
		if (!(acUsed[i] = (int *) calloc (optParam.planningWindowDuration, sizeof (int))))//ac used in a column in the solution
		{
			logMsg(dlFile,"%s Line %d: Out of Memory \n", __FILE__,__LINE__);
			exit(1);
		}

	fprintf (dlFile, "\n\n --> Available aircrafts and covering columns, divided by fleet type : \n\n");
	for(m=0; m < numAcTypes; m++)
	{
		fprintf (dlFile, "\n Fleet Type %d : \n", m );

		for(j=0; j < numAircraft; j++)
		{
			if( acList[j].acTypeIndex != m )
				continue;

			fprintf (dlFile, "Aircraft %d ; Orig available day %d; Available for new tours %d; Available day %d ;  \n", acList[j].aircraftID
			, timeToDay(acList[j].availDT), availAcs[j].availAfter, availAcs[j].day );

			for( k=0; k < optParam.planningWindowDuration; k ++)
			{
				fprintf (dlFile, "On day %d : ", k );

				_ASSERTE( acUsed[j][k] == 0 );
				for(i=0; i < numPickedLpCols; i++)//find an opt col covering this ac on this day
				{
					if( pickedLpCols[i].col->day != k )
						continue;

					if( !pickedLpCols[i].col->cpAcAssignP )//no legs
					{
						if( pickedLpCols[i].col->acInd != j )//use pickedLpCols[i].col->acInd
							continue;
					} else
					{
						for(n=0; n < pickedLpCols[i].col->cpAcAssignP->numAc; n ++)//go through all acs of this duty
							if( pickedLpCols[i].col->cpAcAssignP->acInd[n] == j )
								break;
						if( n >= pickedLpCols[i].col->cpAcAssignP->numAc )//not found
							continue;
					}

					fprintf (dlFile, " %d ; ", i );
					acUsed[j][k] = 1 ;
				}
				if( !acUsed[j][k] )
				{
					_ASSERTE( colStartInd[DL_Col_Ac] + j*optParam.planningWindowDuration + k < colStartInd[DL_Col_Ac+1]
					&& aColToAInd[j*optParam.planningWindowDuration + k] == j );

					fprintf (dlFile, " Not crewed; Uncovered %.2f \n", x[colStartInd[DL_Col_Ac] + j*optParam.planningWindowDuration + k]);
				} else
					fprintf (dlFile, " \n");
			}//end for( k=0; k < optParam.planningWindowDuration; k ++)
		}//end for(j=0; j < numAircraft; j++)
	}//end for(m=0; m < numAcTypes; m++)

	for(j=0; j < numAircraft; j++)
		for( k=0; k < optParam.planningWindowDuration; k ++)
			if( x[colStartInd[DL_Col_Ac] + j*optParam.planningWindowDuration + k] < 1 )
				_ASSERTE( acUsed[j][k] ) ;

////////////////////////////////////////////////////////////////////////////////////////////////////////////for each pilot, print columns containing it
	if (!(pilotUsed = (int *) calloc (numCrew, sizeof (int))))//pilot used in a column in the solution
	{
		logMsg(dlFile,"%s Line %d: Out of Memory \n", __FILE__,__LINE__);
		exit(1);
	}
	fprintf (dlFile, "\n\n --> Available pilots and covering columns, divided by fleet type : \n\n");
	for(m=0; m < numAcTypes; m++)
	{
		fprintf (dlFile, "\n Fleet Type %d : \n", m );

		for(j=0; j < numCrew; j++)
		{
			if( crewList[j].acTypeIndex != m )
				continue;

			fprintf (dlFile, "Pilot %d :", crewList[j].crewID );

			for(i=0; i < numPickedLpCols; i++)
				if( pickedLpCols[i].col->startInfoP->pilotAvail[0].ind == j || pickedLpCols[i].col->startInfoP->pilotAvail[1].ind == j )
				{
					fprintf (dlFile, " %d ; ", i );
					pilotUsed[j] = 1 ;
				}
			if( !pilotUsed[j] && availPilots[j].availAfter )
				fprintf (dlFile, " Not crewing \n");
			else
				fprintf (dlFile, " \n");
		}
	}

/////////////////////////////////////////////////////////////////////////////////////////////////////////for each crew pair, print columns containing it
	fprintf (dlFile, "\n\n --> Available crew pairs and covering columns, divided by fleet type : \n\n");
	for(m=0; m < numAcTypes; m++)
	{
		fprintf (dlFile, "\n Fleet Type %d : \n", m );

		for(j=0; j < numCrewPairs; j++)
		{
			if( crewPairList[j].acTypeIndex != m )
				continue;

			fprintf (dlFile, "Crew pair %d :", j );

			k = 0 ;
			for(i=0; i < numPickedLpCols; i++)
				if( pickedLpCols[i].col->startInfoP->cpInd == j )
				{
					fprintf (dlFile, " %d ; ", i );
					k = 1 ;
				}
			if( !k ) //not used 
			{
				if( pilotUsed[crewPairList[j].crewListInd[0]] || pilotUsed[crewPairList[j].crewListInd[1]] )
					fprintf (dlFile, " Pilot(s) used by other crew pairs \n");
				else
					fprintf (dlFile, " Not crewing \n");
			} else
				fprintf (dlFile, " \n");
		}
	}//end for(m=0; m < numAcTypes; m++)

/////////////////////////////////////////////////////////////////////////////////////////////////////////for each start info, print columns containing it
	fprintf (dlFile, "\n\n --> All possible (crew pair, ac) paris, divided by fleet type : \n\n");
	for(m=0; m < numAcTypes; m++)
	{
		fprintf (dlFile, "\n Fleet Type %d : \n", m );

		for(j=0; j < numStartInfo; j++)
		{
			if( crewPairList[cpAcStartInfos[j].cpInd].acTypeIndex != m )
				continue;

			fprintf (dlFile, "Start info %d, ac (%d), pilots(%d, %d) :", j, acList[cpAcStartInfos[j].acAvail.ind].aircraftID, crewPairList[cpAcStartInfos[j].cpInd].captainID
			, crewPairList[cpAcStartInfos[j].cpInd].flightOffID);

			k = 0 ;
			for(i=0; i < numPickedLpCols; i++)
				if( pickedLpCols[i].col->startInfoP->index == cpAcStartInfos[j].index )
				{
					fprintf (dlFile, " %d ; ", i );
					k = 1 ;
				}
			if( !k ) //not used 
			{
				_ASSERTE( cpAcStartInfos[j].type == DL_NewAvail ) ;

				for(i=0; i < optParam.planningWindowDuration; i++)
					if( acUsed[cpAcStartInfos[j].acAvail.ind][i] )
						break;

				if( i < optParam.planningWindowDuration
				|| pilotUsed[crewPairList[cpAcStartInfos[j].cpInd].crewListInd[0]] || pilotUsed[crewPairList[cpAcStartInfos[j].cpInd].crewListInd[1]] )
					fprintf (dlFile, " Ac/Pilot(s) used by other start info \n");
				else
					fprintf (dlFile, " Not crewing \n");
			} else
				fprintf (dlFile, " \n");
		}
	}//end for(m=0; m < numAcTypes; m++)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////get the crew assignments
	numDlCrewAssigns = 2*DL_MAX_NUM_AC_PER_DUTY*numPickedLpCols;//number of crew assignments
	if (!(dlCrewAssigns = (ProposedCrewAssg *) calloc (numDlCrewAssigns, sizeof (ProposedCrewAssg))))//pilot used in a column in the solution
	{
		logMsg(dlFile,"%s Line %d: Out of Memory \n", __FILE__,__LINE__);
		exit(1);
	}
	if (!(caToOptCol  = (int *) calloc (numDlCrewAssigns, sizeof (int))))
	{
		logMsg(dlFile,"%s Line %d: Out of Memory \n", __FILE__,__LINE__);
		exit(1);
	}
	for(i=0; i < numDlCrewAssigns; i ++)
		caToOptCol[i] = -1 ; //initialize

	k = 0; //index
	for(i=0; i < numPickedLpCols; i ++)
		for(j=0; j < 2; j++)//for each pilot
		{
			_ASSERTE( k < numDlCrewAssigns );

			if( !pickedLpCols[i].col->cpAcAssignP ) //one ac assigned
			{
				dlCrewAssigns[k].aircraftID = acList[pickedLpCols[i].col->acInd].aircraftID ; //first ac
				dlCrewAssigns[k].crewID = crewList[pickedLpCols[i].col->startInfoP->pilotAvail[j].ind].crewID ;
				dlCrewAssigns[k].position = j + 1 ;
				dlCrewAssigns[k].startTm = pickedLpCols[i].col->pDutyStartTm[j] ;
				dlCrewAssigns[k].endTm = pickedLpCols[i].col->endTm + Minute*optParam.postFlightTm;
				caToOptCol[k] = i ;
				k ++;
			} else
			{
				tempTm = pickedLpCols[i].col->pDutyStartTm[j] ;//start time of current ac
				for(m=0; m<pickedLpCols[i].col->cpAcAssignP->numAc; m ++)//go through each ac
				{
					dlCrewAssigns[k].aircraftID = acList[pickedLpCols[i].col->acInd].aircraftID ; //first ac
					dlCrewAssigns[k].crewID = crewList[pickedLpCols[i].col->startInfoP->pilotAvail[j].ind].crewID ;
					dlCrewAssigns[k].position = j + 1 ;
					dlCrewAssigns[k].startTm = tempTm ;//note
					if( m == pickedLpCols[i].col->cpAcAssignP->numAc-1 )//last ac
						dlCrewAssigns[k].endTm = pickedLpCols[i].col->endTm + Minute*optParam.postFlightTm;
					else
					{
						dlCrewAssigns[k].endTm = legInfosCP[pickedLpCols[i].col->cpAcAssignP->acEndLeg[m]].leg->schedIn ;//leg end time
						tempTm = dlCrewAssigns[k].endTm ;
					}
					caToOptCol[k] = i ;
					k ++;
				}//end for(m=0; m<pickedLpCols[i].col->cpAcAssignP->numAc; m ++)//go through each ac
			}//end more than one acs
		}//end for(j=0; j < 2; j++)//for each pilot

	_ASSERTE( k <= numDlCrewAssigns );
	numDlCrewAssigns = k ;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////check solution
	//crew assigments sorted by crew ID, then start time
	for(i=0; i < numDlCrewAssigns; i ++)
	{
		_ASSERTE( caToOptCol[i] >= 0 );
		curDutyP = pickedLpCols[caToOptCol[i]].col ;

		_ASSERTE( dlCrewAssigns[i].crewID == crewPairList[curDutyP->startInfoP->cpInd].captainID
		|| dlCrewAssigns[i].crewID == crewPairList[curDutyP->startInfoP->cpInd].flightOffID );

		k = ( dlCrewAssigns[i].crewID == crewPairList[curDutyP->startInfoP->cpInd].captainID ? 0 : 1 ); //captain or officer
		m = ( pickedLpCols[caToOptCol[i]].fDuty && curDutyP->startInfoP->pilotAvail[k].status == PilotRestB4FirstLeg ) ;//whether first duty of a pilot tour

		_ASSERTE( dlCrewAssigns[i].position == k + 1
		&& (dlCrewAssigns[i].endTm - dlCrewAssigns[i].startTm <= getCurMaxDutyTm(m, dlCrewAssigns[i].startTm, pickedLpCols[caToOptCol[i]].col->pAirports[k] )
		|| curDutyP->keepOriginal )//max duty time
		&& ( !curDutyP->cpAcAssignP //contain the original interval
		|| ((dlCrewAssigns[i].startTm <= curDutyP->cpAcAssignP->firstLegP->leg->schedOut || curDutyP->cpAcAssignP->tmFixed == DL_StartTmFixed 
			|| curDutyP->cpAcAssignP->tmFixed == DL_BothTmFixed )
			&& dlCrewAssigns[i].endTm >= curDutyP->cpAcAssignP->lastLegP->leg->schedIn ))); 

		//between duties of the same pilot
		for(j=0; j < numDlCrewAssigns; j ++)
		{
			if( j == i || dlCrewAssigns[j].crewID != dlCrewAssigns[i].crewID )
				continue ;

			_ASSERTE( dlCrewAssigns[j].startTm >= dlCrewAssigns[i].endTm || dlCrewAssigns[i].startTm >= dlCrewAssigns[j].endTm );

			if( caToOptCol[j] == caToOptCol[i] )//same duty, no rest
				_ASSERTE( dlCrewAssigns[j].aircraftID != dlCrewAssigns[i].aircraftID 
				&& (dlCrewAssigns[j].startTm == dlCrewAssigns[i].endTm || dlCrewAssigns[i].startTm == dlCrewAssigns[j].endTm ));
			else
				_ASSERTE( dlCrewAssigns[j].startTm - dlCrewAssigns[i].endTm >= Minute*optParam.minRestTm 
				|| dlCrewAssigns[i].startTm - dlCrewAssigns[j].endTm >= Minute*optParam.minRestTm );
		}

		//between duties of the same ac
		for(j=0; j < numDlCrewAssigns; j ++)
		{
			if( j == i || dlCrewAssigns[j].aircraftID != dlCrewAssigns[i].aircraftID )
				continue ;
			
			if( caToOptCol[j] == caToOptCol[i] )//same duty, one capatin, one officer
			{
				_ASSERTE(dlCrewAssigns[j].endTm == dlCrewAssigns[i].endTm && dlCrewAssigns[j].crewID == crewList[curDutyP->startInfoP->pilotAvail[1-k].ind].crewID);
				continue;
			}

			_ASSERTE( optParam.postFlightTm > optParam.turnTime && (curDutyP->startTm >= pickedLpCols[caToOptCol[j]].col->endTm + Minute*optParam.turnTime 
			|| curDutyP->endTm + Minute*optParam.turnTime <= pickedLpCols[caToOptCol[j]].col->startTm ));
		}

		if( !curDutyP->cpAcAssignP || curDutyP->cpAcAssignP->numAc == 1 )//one ac assigned
		{
			_ASSERTE( dlCrewAssigns[i].startTm == curDutyP->pDutyStartTm[k] 
			&& dlCrewAssigns[i].endTm == curDutyP->endTm + Minute*optParam.postFlightTm && dlCrewAssigns[i].aircraftID ==  acList[curDutyP->acInd].aircraftID );
		}  else
		{
			for(m=0; m<curDutyP->cpAcAssignP->numAc; m ++)//go through each ac
				if( acList[curDutyP->cpAcAssignP->acInd[m]].aircraftID == dlCrewAssigns[i].aircraftID )//found
				{
					if( m == 0 )//first ac
						_ASSERTE( dlCrewAssigns[i].startTm == curDutyP->pDutyStartTm[k]);
					else
						_ASSERTE( dlCrewAssigns[i].startTm == legInfosCP[curDutyP->cpAcAssignP->acEndLeg[m-1]].leg->schedIn );//previous ac end time

					if( m == curDutyP->cpAcAssignP->numAc - 1 )//last ac
						_ASSERTE( dlCrewAssigns[i].endTm == curDutyP->endTm + Minute*optParam.postFlightTm );
					else
						_ASSERTE( dlCrewAssigns[i].endTm == legInfosCP[curDutyP->cpAcAssignP->acEndLeg[m]].leg->schedIn );

					break;
				}
			_ASSERTE( m<curDutyP->cpAcAssignP->numAc );//must contain
		}
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////end check solution

	//after checking solution
	qsort((void *) dlCrewAssigns, numDlCrewAssigns, sizeof(ProposedCrewAssg), compareCrewAssign);

	fprintf (dlFile, "\n --> Crew assignments ( %d total ) :\n", numDlCrewAssigns);

	fprintf (dlFile, "+-----------+---------------+----------+--------------------+-------------------+\n");
	fprintf (dlFile, "|  Crew ID  |  Aircraft ID  | Position |     Start Time     |     End Time      |\n");
	fprintf (dlFile, "+-----------+---------------+----------+--------------------+-------------------+\n");
	for (i=0; i<numDlCrewAssigns; i++)
		fprintf (dlFile, "|  %6d   |    %6d     |    %1d     |  %15s  |  %15s |\n",
					dlCrewAssigns[i].crewID,
					dlCrewAssigns[i].aircraftID,
					dlCrewAssigns[i].position,
					dt_DateTimeToDateTimeString(dt_time_tToDateTime (dlCrewAssigns[i].startTm), opbuf1, "%Y/%m/%d %H:%M"),
					dt_DateTimeToDateTimeString(dt_time_tToDateTime (dlCrewAssigns[i].endTm), opbuf2, "%Y/%m/%d %H:%M"));
	fprintf (dlFile, "+-----------+---------------+----------+--------------------+-------------------+\n\n");

	*crewAssignP = dlCrewAssigns ;
	*numCrewAssignP = numDlCrewAssigns ;


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////total cost
	oTravelCost = nTravelCost = 0 ;
	for(i=0; i < numPickedLpCols; i++)
	{
		if( pickedLpCols[i].col->startInfoP->type == DL_NewAvail )
			nTravelCost += pickedLpCols[i].col->cost ;
		else
			oTravelCost += pickedLpCols[i].col->cost ;
	}

	demPen = acPen = 0 ;
	for(i=colStartInd[DL_Col_Dem]; i < colStartInd[DL_Col_Dem+1]; i++)
		if( x[i] > 0 )
			demPen += tempCO*x[i] ;

	for(i=colStartInd[DL_Col_Ac]; i < colStartInd[DL_Col_Ac+1]; i++)
		if( x[i] > 0 )
			acPen += tempCO*x[i] ;

	if ( status = CPXgetobjval (env, lp, &tCost) ) 
	{
		logMsg(dlFile, "Failed to get objective function value.\n");
		CPXgeterrorstring (env, status, charBuf);
		logMsg(dlFile,"%s", charBuf);
		exit(1);
	}
	//_ASSERTE( tCost == oTravelCost + nTravelCost + demPen + acPen);

	fprintf(dlFile, "\n Previous travel cost: %.2f \n New Additionl travel cost: %.2f \n Demand covering penalty: %.2f \n Aircraft crewing penalty: %.2f \n Total : %.2f \n Objective: %.2f \n "
	, oTravelCost , nTravelCost , demPen , acPen, oTravelCost + nTravelCost + demPen + acPen, tCost); 

	for(i=0; i < numPickedLpCols; i++)
	{
		if( !pickedLpCols[i].col->keepOriginal )
			continue;

		switch ( pickedLpCols[i].col->keepOriginal )
		{
			case DL_KO_DutyTime:
				fprintf(dlFile, " Duty %d original: Maximum duty time violates \n", i);
				break;

			case DL_KO_TmFixed:
				fprintf(dlFile, " Duty %d original: Start and end time fixed \n", i);
				break;

			case DL_KO_NoTravel:
				fprintf(dlFile, " Duty %d original: No feasible travels \n", i);
				break;

			case DL_KO_Combined:
				fprintf(dlFile, " Duty %d original: Combined with other duties \n", i);
				break;

			default:
				_ASSERTE( 0 == 1);
		}
	}

	fflush(dlFile);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////end print out solution

	if( x != NULL )
	{
		free( x );
		x = NULL;
	}
	if( pickedLpCols != NULL )
	{
		free(pickedLpCols);
		pickedLpCols = NULL;
	}
	if( acUsed != NULL )
	{
		for( k=0; k < optParam.planningWindowDuration; k ++)
		{
			free( acUsed[k] );
			acUsed[k] = NULL ;
		}
		free( acUsed );
		acUsed = NULL;
	}
	if( pilotUsed != NULL )
	{
		free( pilotUsed );
		pilotUsed = NULL;
	}
	if( caToOptCol != NULL )
	{
		free(caToOptCol );
		caToOptCol = NULL ;
	}
	
	return 0;
}


static int generateColumns( const DL_AvailInfo *availPilots, const DL_CpAcAssign **cpAcAssigns, const DL_CpAcStartInfo *cpAcStartInfos
, const int numStartInfo, DL_Column *****naP, int ****numNAP)
{
	int i, fDay, dayZero, dayOne ;
	DL_Column ****newAssigns = NULL;
	int ***numNewAssigns = NULL;
	DL_CpAcAssign *prevCpAc=NULL, *curCpAc=NULL ;

	_ASSERTE( numStartInfo > 0 );
	if (!(newAssigns = (DL_Column ****) calloc (numStartInfo, sizeof (DL_Column***))))
	{
		logMsg(dlFile,"%s Line %d: Out of Memory \n", __FILE__,__LINE__);
		exit(1);
	}
	if (!(numNewAssigns = (int ***) calloc (numStartInfo, sizeof (int**))))
	{
		logMsg(dlFile,"%s Line %d: Out of Memory \n", __FILE__,__LINE__);
		exit(1);
	}

	for(i=0; i < numStartInfo ; i ++)
	{
		if (!(newAssigns[i] = (DL_Column ***) calloc (optParam.planningWindowDuration, sizeof (DL_Column**))))
		{
			logMsg(dlFile,"%s Line %d: Out of Memory \n", __FILE__,__LINE__);
			exit(1);
		}
		if (!(numNewAssigns[i] = (int **) calloc (optParam.planningWindowDuration, sizeof (int*))))
		{
			logMsg(dlFile,"%s Line %d: Out of Memory \n", __FILE__,__LINE__);
			exit(1);
		}

		for(fDay=0; fDay < optParam.planningWindowDuration; fDay ++)
		{
			if (!(newAssigns[i][fDay] = (DL_Column **) calloc (2, sizeof (DL_Column*))))
			{
				logMsg(dlFile,"%s Line %d: Out of Memory \n", __FILE__,__LINE__);
				exit(1);
			}
			if (!(numNewAssigns[i][fDay] = (int *) calloc (2, sizeof (int))))
			{
				logMsg(dlFile,"%s Line %d: Out of Memory \n", __FILE__,__LINE__);
				exit(1);
			}
		}

		fDay = -1 ; //first feasible crewing duty: including travels
		//process days before  cpAcStartInfos[i].legStartDay: 
		//dayZero: first crewing duty
		for( dayZero = cpAcStartInfos[i].acCpDay; dayZero <= cpAcStartInfos[i].legStartDay; dayZero ++ )
			if( !generateAnAssignment( availPilots, cpAcAssigns, &(cpAcStartInfos[i]), dayZero, dayZero, &(newAssigns[i][dayZero][0]), &(numNewAssigns[i][dayZero][0])) 
			&& fDay == -1 )
				fDay = dayZero ;

		if( fDay >= 0 )//if there exist feasible crew days
			for( dayOne=fDay+1; dayOne <= cpAcStartInfos[i].lastPossibleDay; dayOne ++ )//process days that do not include travels
				generateAnAssignment( availPilots, cpAcAssigns, &(cpAcStartInfos[i]), -1, dayOne, &( newAssigns[i][dayOne][1]), &(numNewAssigns[i][dayOne][1]) );
	}//end for(i=0; i < numStartInfo ; i ++)


	*naP = newAssigns ;
	*numNAP = numNewAssigns ;
	return 0;
}


static int checkColumns(const DL_LegInfo *legInfosCP, const DL_CpAcAssign **cpAcAssigns, const DL_CpAcStartInfo *cpAcStartInfos, const int numStartInfo
, const DL_Column ****naP, const int ***numNAP)
{
	int i, j, k, m, day;
	int *flags = NULL;
	const time_t longRestTm =  Minute*(optParam.minRestTm + optParam.postFlightTm + optParam.preFlightTm) ;

	_ASSERTE( naP && numNAP ); // && naColumns && numNACols ) ;

	if (!(flags = (int *) calloc (numPropMgdLegs, sizeof (ProposedMgdLeg))))
	{
		logMsg(dlFile,"%s Line %d: Out of Memory \n", __FILE__,__LINE__);
		exit(1);
	}

	for(i=0; i < numStartInfo ; i ++)
	{
		_ASSERTE( naP[i] && numNAP[i] );//allocated

		for( day=0; day < optParam.planningWindowDuration; day ++ )//check each possible day to start
		{
			_ASSERTE( naP[i][day] && numNAP[i][day] );//allocated

			if( cpAcStartInfos[i].type != DL_NewAvail && cpAcAssigns[cpAcStartInfos[i].cpInd] && cpAcAssigns[cpAcStartInfos[i].cpInd][day].numAc )
				_ASSERTE( numNAP[i][day][0] + numNAP[i][day][1] );

			for( k=0; k<2; k++ ) //two types: k=0 --> first duty
			{
				if( numNAP[i][day][k] )//duties generated
				{
					_ASSERTE( naP[i][day][k] && numNAP[i][day][k] > 0 );

					for(j=0; j <numNAP[i][day][k]; j ++)//for each duty
					{
						const DL_Column *curP = &(naP[i][day][k][j]) ;

						_ASSERTE( !curP->keepOriginal || (numNAP[i][day][k] == 1 && curP->cpAcAssignP && curP->cost == 0 ));

						_ASSERTE( curP->startInfoP == &(cpAcStartInfos[i]) //same start info
						&& curP->day == day  //same day
						&& ( curP->firstDay == -1 || curP->startInfoP->acCpDay <= curP->firstDay ) //start after available
						&& (curP->endTm - curP->startTm >= MinCrewInterval || curP->cpAcAssignP ) //long enough interval
						&& curP->cost >= 0 //valid cost
						&& curP->acInd >= 0
						&& curP->startInfoP->acCpDay <= day && day <= curP->startInfoP->lastPossibleDay//day in range
						&& ((curP->pilotStartTm[0] < curP->startTm && curP->pilotStartTm[1] < curP->startTm ) || ( curP->cpAcAssignP 
							&& (curP->cpAcAssignP->tmFixed == DL_StartTmFixed || curP->cpAcAssignP->tmFixed == DL_BothTmFixed )))
						&& curP->pilotStartTm[0] > 0 && curP->pilotStartTm[1] > 0 
						&& curP->pilotStartTm[0] <= curP->pDutyStartTm[0] && curP->pilotStartTm[1] <= curP->pDutyStartTm[1]
						&& ( curP->keepOriginal || (curP->acAirport > 0 && curP->acTm > 0 && curP->pAirports[0] > 0 && curP->pTm[0] > 0 && curP->pAirports[1] > 0 && curP->pTm[1] > 0 ))); //valid start time

						if( k ) //not the first duty
							_ASSERTE( curP->day > curP->firstDay //not the first duty
							&& curP->cost == 0 //no travels
							&& (curP->day <= curP->startInfoP->legStartDay || curP->pilotStartTm[0] == curP->pilotStartTm[1]) ); //no travels
						else//first duty
							_ASSERTE( curP->day == curP->firstDay );

						if( curP->cpAcAssignP ) //legs on current day
						{
							_ASSERTE( curP->startInfoP->type != DL_NewAvail //must be an opt tour
							&& (k || curP->startInfoP->acAvail.ind == curP->cpAcAssignP->acInd[0]) //same ac for the first duty
							&& curP->startInfoP->cpInd == curP->cpAcAssignP->firstLegP->leg->crewPairInd //same cp
							&& cpAcAssigns[curP->startInfoP->cpInd] && cpAcAssigns[curP->startInfoP->cpInd][day].numAc
							&& curP->cpAcAssignP == &( cpAcAssigns[curP->startInfoP->cpInd][day] ) //same duty
							&& curP->startTm <= curP->cpAcAssignP->firstLegP->leg->schedOut && curP->endTm >= curP->cpAcAssignP->lastLegP->leg->schedIn ); //vaild crew interval
							//connect following legs
							if( curP->cpAcAssignP->tmFixed == DL_EndTmFixed || curP->cpAcAssignP->tmFixed == DL_BothTmFixed )
								_ASSERTE( curP->endTm == curP->cpAcAssignP->lastLegP->leg->schedIn );
							else
							{
								if( curP->cpAcAssignP->lastLegP->nextAcLeg )
									_ASSERTE( curP->endTm + Minute*optParam.turnTime <= curP->cpAcAssignP->lastLegP->nextAcLeg->leg->schedOut );

								for(m=0; m <2; m++)
									if( curP->cpAcAssignP->lastLegP->nextPilotLegs[m] )
										_ASSERTE( curP->endTm + longRestTm <= curP->cpAcAssignP->lastLegP->nextPilotLegs[m]->leg->schedOut );
							}
							//connect previous legs
							if( curP->cpAcAssignP->tmFixed == DL_StartTmFixed || curP->cpAcAssignP->tmFixed == DL_BothTmFixed )
								_ASSERTE( curP->startTm == curP->cpAcAssignP->firstLegP->leg->schedOut );
							else
							{
								if( curP->cpAcAssignP->firstLegP->prevAcLeg )
									_ASSERTE( curP->cpAcAssignP->firstLegP->prevAcLeg->leg->schedIn + Minute*optParam.turnTime <= curP->startTm );

								for(m=0; m <2; m++)
									if( curP->cpAcAssignP->firstLegP->prevPilotLegs[m] )
										_ASSERTE( curP->cpAcAssignP->firstLegP->prevPilotLegs[m]->leg->schedIn + longRestTm <= curP->startTm );
							}
						} else
						{
							_ASSERTE( !cpAcAssigns[curP->startInfoP->cpInd] || !cpAcAssigns[curP->startInfoP->cpInd][day].numAc ) ;
						}
					}//end j
				} else //end if( numNAP[i][day][k] )
					_ASSERTE( !cpAcAssigns[cpAcStartInfos[i].cpInd] || !cpAcAssigns[cpAcStartInfos[i].cpInd][day].numAc 
					|| ( cpAcStartInfos[i].type != DL_NewAvail && ( (k==0 && day > cpAcStartInfos[i].legStartDay) || (k==1 && day == cpAcStartInfos[i].legStartDay )))
					|| ( cpAcStartInfos[i].type == DL_NewAvail && day < cpAcStartInfos[i].acCpDay ));
			}//end for( k=0; k<2; k++ ) 
		}//end for( day=0; day < optParam.planningWindowDuration; day ++ )
	}//end for(i=0; i < numStartInfo ; i ++)

	if( flags )
	{
		free(flags);
		flags=NULL;
	}

	return 0;
}

static int timeToDay(const time_t timeT)
{
	int day;

	for(day=0; day < MAX_WINDOW_DURATION; day ++)
		if( timeT <= firstEndOfDay + day*DayInSecs)
			break;
	//_ASSERTE( day < optParam.planningWindowDuration );
	day = min( day, optParam.planningWindowDuration - 1); //if day is later

	return day;
}

static int acIDToInd(const int acID)
{
	int acInd;

	_ASSERTE( acID > 0 );
	for(acInd = 0; acInd < numAircraft; acInd ++)
		if( acList[acInd].aircraftID == acID )
			break;
	_ASSERTE( acInd < numAircraft );

	return acInd;
}

static int generateCurrentCpDutyAssign(const DL_DemUsedType *dlDemUsed, DL_LegInfo *legInfosCP, DL_CpAcAssign ***cpAcAssignsP )
{
	int day,firstTourLeg, lastTourLeg, lastDutyLeg, firstDutyLeg, acInd[DL_MAX_NUM_AC_PER_DUTY], acEndLeg[DL_MAX_NUM_AC_PER_DUTY] ;
	int j, m, numAcInd, cpInd, dutyNum ;
	DL_CpAcAssign **cpAcAssigns, *curDutyP=NULL, *nextDutyP=NULL ;
	DL_LegInfo *legP=NULL ;
	const time_t longRestTm =  Minute*(optParam.minRestTm + optParam.postFlightTm + optParam.preFlightTm) ;

	//allocate
	_ASSERTE( numCrewPairs > 0 ) ;
	if (!(cpAcAssigns = (DL_CpAcAssign **) calloc (numCrewPairs, sizeof (DL_CpAcAssign*))))
	{
		logMsg(dlFile,"%s Line %d: Out of Memory \n", __FILE__,__LINE__);
		exit(1);
	}

	//go through legs to find duties of each pilot
	firstTourLeg = 0 ;//index in legInfosCP[]
	while( firstTourLeg < numPropMgdLegs )
	{
		cpInd = legInfosCP[firstTourLeg].leg->crewPairInd ; //current cp

		//starting from firstTourLeg, get last leg of the same cp
		//assume legs are sorted
		for(lastTourLeg = firstTourLeg ; lastTourLeg < numPropMgdLegs-1 ; lastTourLeg ++)//numPropMgdLegs-1
			if( legInfosCP[lastTourLeg+1].leg->crewPairInd !=  cpInd )
				break;
		
		//current tour: [firstTourLeg, lastTourLeg]: all legs of this crew pair ind 
		//allocate
		_ASSERTE( cpAcAssigns[cpInd] == NULL );
		if( !( cpAcAssigns[cpInd] = (DL_CpAcAssign *) calloc (optParam.planningWindowDuration, sizeof (DL_CpAcAssign))))
		{
			logMsg(dlFile,"%s Line %d: Out of Memory \n", __FILE__,__LINE__);
			exit(1);
		}

		//go through all legs in [firstTourLeg, lastTourLeg] to find all duties
		firstDutyLeg = firstTourLeg ; //initialize first leg of first duty
		dutyNum = 0; //dutyNum-th duty in this tour
		while( firstDutyLeg <= lastTourLeg )
		{
			//find end of this duty
			for( lastDutyLeg = firstDutyLeg ; lastDutyLeg < lastTourLeg; lastDutyLeg ++)
				if ( legInfosCP[lastDutyLeg+1].leg->schedOut - legInfosCP[lastDutyLeg].leg->schedIn >= longRestTm )
					break;

			//current duty: [firstDutyLeg, lastDutyLeg]
			//find the day of this duty //return the first day if un-decidable (e.g. single leg across two days)
			getDayFromMgdLegs(dlDemUsed, legInfosCP, firstDutyLeg, lastDutyLeg, &day) ;
			
			//get list of acs assigned to this duty
			getAcIndFromMgdLegs(legInfosCP, firstDutyLeg, lastDutyLeg, acInd, acEndLeg, &numAcInd ) ;

			curDutyP = &(cpAcAssigns[cpInd][day]) ;
			if( curDutyP->numAc > 0 ) //this cp has been assigned: possible when more than one duties on a single day
			{
				_ASSERTE( curDutyP->firstLegP != NULL && curDutyP->lastLegP != NULL && curDutyP->acInd[0] >= 0 && curDutyP->numAc >= 1 
				&& curDutyP->lastLegP->legIndCP == firstDutyLeg - 1 && numAcInd > 0 ) ; //assume order

				//add new acs
				if( acInd[0] == curDutyP->acInd[curDutyP->numAc-1] )//check the first ac: if the first ac is the same as the last ac, skip
				{
					m = 1 ;
					curDutyP->acEndLeg[curDutyP->numAc-1] = acEndLeg[0] ;
				} else
					m = 0 ;
				for( j = m; j < numAcInd; j++ )
				{
					curDutyP->acInd[curDutyP->numAc] = acInd[j] ;
					curDutyP->acEndLeg[curDutyP->numAc] = acEndLeg[j] ;
					(curDutyP->numAc) ++ ;
					_ASSERTE( curDutyP->numAc <= DL_MAX_NUM_AC_PER_DUTY ) ;
				}
				//update the last leg of the duty
				curDutyP->lastLegP = &(legInfosCP[lastDutyLeg]) ;
				curDutyP->tmFixed = DL_DutyCombined ;
			} else
			{
				curDutyP->firstLegP = &(legInfosCP[firstDutyLeg]) ;
				curDutyP->lastLegP = &(legInfosCP[lastDutyLeg]) ;
				curDutyP->dutyNum = dutyNum ;
				curDutyP->pilotDays[1] = curDutyP->pilotDays[0] = -1 ;
				//curDutyP->fromExistTour =  curDutyP->firstLegP->leg->exgTour ;
				curDutyP->numAc = numAcInd ;
				memmove( curDutyP->acInd, acInd, sizeof(curDutyP->acInd)) ;
				memmove( curDutyP->acEndLeg, acEndLeg, sizeof(curDutyP->acEndLeg)) ;

				if( curDutyP->firstLegP->noPilotRest[0][0] || curDutyP->firstLegP->noPilotRest[1][0] || curDutyP->lastLegP->noPilotRest[0][1] || curDutyP->lastLegP->noPilotRest[1][1] )
					curDutyP->tmFixed = DL_BothTmFixed ;
				else
				{
					if( curDutyP->firstLegP->noAcTurn[0] || curDutyP->firstLegP->leg->schedOut <= optParam.windowStart
					|| acList[acInd[0]].availDT >= curDutyP->firstLegP->leg->schedOut 
					|| crewList[crewPairList[cpInd].crewListInd[0]].availDT + Minute*( crewList[crewPairList[cpInd].crewListInd[0]].activityCode == 2 ? optParam.firstPreFltTm 
					: optParam.preFlightTm ) >= curDutyP->firstLegP->leg->schedOut
					|| crewList[crewPairList[cpInd].crewListInd[1]].availDT + Minute*( crewList[crewPairList[cpInd].crewListInd[1]].activityCode == 2 ? optParam.firstPreFltTm 
					: optParam.preFlightTm ) >= curDutyP->firstLegP->leg->schedOut )
						curDutyP->tmFixed = DL_StartTmFixed ;

					if( curDutyP->lastLegP->noAcTurn[1] || curDutyP->lastLegP->leg->schedIn + Minute*optParam.turnTime >= optParam.windowEnd )
						curDutyP->tmFixed = ( curDutyP->tmFixed == DL_StartTmFixed ? DL_BothTmFixed : DL_EndTmFixed ) ;
				}
				dutyNum ++ ; 
			}//end if( !flag )

			//get day for each leg
			for(j=firstDutyLeg; j <= lastDutyLeg; j ++)
			{
				_ASSERTE( legInfosCP[j].day == -1 );
				legInfosCP[j].day = day ;
			}
			
			firstDutyLeg = lastDutyLeg + 1; //update new duty start
		}//while( firstDutyLeg <= lastTourLeg )
		firstTourLeg = lastTourLeg + 1; //update tour
	}//end ( firstTourLeg < numPropMgdLegs )

	//go through each cp assignment, and fix start time and end time for special cases
	for( cpInd=0; cpInd < numCrewPairs; cpInd ++)
	{
		if( cpAcAssigns[cpInd] == NULL )
			continue;

		for( day=0; day < optParam.planningWindowDuration; day ++)
		{
			//if not assigned on current day, or both start and end times are already fixed
			if( !cpAcAssigns[cpInd][day].numAc || cpAcAssigns[cpInd][day].tmFixed >= DL_BothTmFixed)
				continue;

			curDutyP = &(cpAcAssigns[cpInd][day]) ;

			//find the next assigned day
			nextDutyP = NULL ;
			for( j = day+1; j < optParam.planningWindowDuration; j ++)
				if( cpAcAssigns[cpInd][j].numAc )
				{
					nextDutyP = &(cpAcAssigns[cpInd][j]) ;
					break;
				}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////check ac
			//if ac is dropped off after current duty, and used later, then fix the end time of current duty and start time of the next duty with the same  ac
			if( ( !nextDutyP || curDutyP->lastLegP->acInd != nextDutyP->firstLegP->acInd )//ac dropped off by this crew pair
			&& (legP = curDutyP->lastLegP->nextAcLeg) != NULL && legP->leg->crewPairInd != cpInd //ac used later by another cp
			&& legP->legIndCP == cpAcAssigns[legP->leg->crewPairInd][legP->day].firstLegP->legIndCP ) //ac used in the first leg of a duty
			{
				//next ac leg
				_ASSERTE( cpAcAssigns[legP->leg->crewPairInd] != NULL && cpAcAssigns[legP->leg->crewPairInd][legP->day].numAc ) ;

				if( curDutyP->tmFixed == DL_NotFixed )
					curDutyP->tmFixed = DL_EndTmFixed ;
				else if( curDutyP->tmFixed == DL_StartTmFixed )
					curDutyP->tmFixed = DL_BothTmFixed ;

				if( cpAcAssigns[legP->leg->crewPairInd][legP->day].tmFixed == DL_NotFixed )
					cpAcAssigns[legP->leg->crewPairInd][legP->day].tmFixed = DL_StartTmFixed ;
				else if( cpAcAssigns[legP->leg->crewPairInd][legP->day].tmFixed == DL_EndTmFixed )
					cpAcAssigns[legP->leg->crewPairInd][legP->day].tmFixed = DL_BothTmFixed ;
			}

			//check pilot
			if( !nextDutyP )//if last duty of the current crew pair
				for(m=0; m<2; m++)
				{
					if( ( legP = curDutyP->lastLegP->nextPilotLegs[m]) != NULL )
					{
						_ASSERTE( legP->leg->crewPairInd != cpInd && !curDutyP->lastLegP->noPilotRest[m][1] && !legP->noPilotRest[m][0] 
						&& cpAcAssigns[legP->leg->crewPairInd] != NULL && cpAcAssigns[legP->leg->crewPairInd][legP->day].numAc
						&& legP->legIndCP == cpAcAssigns[legP->leg->crewPairInd][legP->day].firstLegP->legIndCP );//legP is the first leg in its duty

						if( curDutyP->tmFixed == DL_NotFixed )
							curDutyP->tmFixed = DL_EndTmFixed ;
						else if( curDutyP->tmFixed == DL_StartTmFixed )
							curDutyP->tmFixed = DL_BothTmFixed ;

						if( cpAcAssigns[legP->leg->crewPairInd][legP->day].tmFixed == DL_NotFixed )
							cpAcAssigns[legP->leg->crewPairInd][legP->day].tmFixed = DL_StartTmFixed ;
						else if( cpAcAssigns[legP->leg->crewPairInd][legP->day].tmFixed == DL_EndTmFixed )
							cpAcAssigns[legP->leg->crewPairInd][legP->day].tmFixed = DL_BothTmFixed ;
					}
				}
			//end if( j >= optParam.planningWindowDuration )

			//consider the case of rest time is between longRestTm and longRestTm + 2*DiscrtLPInterval
			if( curDutyP->tmFixed != DL_BothTmFixed && curDutyP->tmFixed != DL_StartTmFixed )
			{
				for(m=0; m<2; m++)
				{
					if( legP = curDutyP->firstLegP->prevPilotLegs[m]) //previous 
					{
						_ASSERTE( legP->leg->schedIn + longRestTm <= curDutyP->firstLegP->leg->schedOut );
						if( legP->leg->schedIn + longRestTm + 2*DiscrtLPInterval > curDutyP->firstLegP->leg->schedOut )
						{
							if( curDutyP->tmFixed == DL_NotFixed )
								curDutyP->tmFixed = DL_StartTmFixed ;
							else if( curDutyP->tmFixed == DL_EndTmFixed )
								curDutyP->tmFixed = DL_BothTmFixed ;
							break;
						}
					}
				}
			}//end if( curDutyP->tmFixed != DL_BothTmFixed && curDutyP->tmFixed != DL_StartTmFixed )

		}//end for( day=0; day < optParam.planningWindowDuration; day ++)
	}//end for( cpInd=0; cpInd < numCrewPairs; cpInd ++)

	*cpAcAssignsP = cpAcAssigns ;
	return 0;
}

static int getDayFromMgdLegs(const DL_DemUsedType *dlDemUsed, const DL_LegInfo *legInfosCP, const int sInd, const int eInd, int *dayP)
{
	int i, j ;

	//duty: [firstDutyLeg, n], find the day of this duty
	*dayP = -1 ; //initial
	
	for( i = sInd; i <= eInd; i ++)
	{
		//if there is a non-trivial demand, return day of the demand
		if( legInfosCP[i].leg->demandID > 0 )
		{
			*dayP= legInfosCP[i].schOutDay ;
			break;
		}
		//if same day for two consecutive legs, return 
		if( i < eInd && legInfosCP[i].schInDay == legInfosCP[i+1].schOutDay )
		{
			*dayP = legInfosCP[i].schInDay ;
			break;
		}
	}

	if( *dayP == -1 ) //not setted, remaining case: all legs are repo legs, and if there are more than one leg, then they are on different days
	{
		//case 1: two or more repo legs, find the maint/app in between, and set day
		for( i = sInd; i < eInd; i ++)
			if( legInfosCP[i].schInDay != legInfosCP[i+1].schOutDay )
			{
				//find the maint/app in between
				for( j = 0; j < numDemand; j ++ )
					if( demandList[j].isAppoint && dlDemUsed[j] && demandList[j].aircraftID == legInfosCP[i].leg->aircraftID
					&& outTimes[j] >= legInfosCP[i].leg->schedIn && inTimes[j] <= legInfosCP[i+1].leg->schedOut )
						break;

				_ASSERTE( j <  numDemand );
				*dayP = timeToDay(outTimes[j]) ;
				break ;
			}

		//case 2: single repo leg, return the early start day
		if( *dayP == -1 )
		{
			_ASSERTE ( legInfosCP[sInd].leg->demandID <= 0 && sInd == eInd );
			*dayP = legInfosCP[sInd].schOutDay ;
		}
	}//end if( day == -1 )

	_ASSERTE( *dayP >= 0 && *dayP < optParam.planningWindowDuration );
	return 0 ;
}

static int getAcIndFromMgdLegs(const DL_LegInfo *legInfosCP,  const int sInd, const int eInd, int *acInd, int *acEndLeg, int *numAcP)
{
	int i ;

	//initialize//acInd not unique
	for(i = 0; i < DL_MAX_NUM_AC_PER_DUTY; i ++ )
	{
		acInd[i] = -1;
		acEndLeg[i] = -1;
	}

	*numAcP = 0;
	for( i = sInd; i <= eInd; i ++)
		if( i == eInd || legInfosCP[i].leg->aircraftID != legInfosCP[i+1].leg->aircraftID ) //i: last leg of this ac
		{
			/*
			//check whether this ac is in the list
			for(j = 0; j < *numAcP; j ++)
				if( propMgdLegsCP[i].aircraftID == acList[acInd[j]].aircraftID )
					break ;
			if( j < *numAcP )//ac is alreadu kept
				continue ;
			*/

			acInd[*numAcP] = legInfosCP[i].acInd ;
			acEndLeg[*numAcP] = i ;

			(*numAcP) ++ ;
			_ASSERTE( *numAcP < DL_MAX_NUM_AC_PER_DUTY );
		}

	_ASSERTE( *numAcP > 0 );
	return 0 ;
}

static int generateCpAcStartInfo(const DL_DemUsedType *dlDemUsed, const DL_LegInfo *legInfosCP, const DL_CpAcAssign **cpAcAssigns, const int *longMaint
, const int numLongMaint, DL_CpAcStartInfo **cpAcStartInfosP, int *numStartInfoP, DL_AvailInfo **availAcsP, DL_AvailInfo **availPilotsP)
{
	int i, j, day, k, m, n, acInd, pInds[2]; // *pilotInLegs, *acInLegs, *availACApt, *availPilotApt, *availPilotDay ;
	time_t tempTm, departTm, dutyStartTm, arrivalTm ;
	DL_CpAcStartInfo *infoP=NULL ; //, tempInfo ;
	DL_LegInfo *firstLeg=NULL, *lastLeg=NULL ;
	DL_AvailInfo *availAcs=NULL, *availPilots=NULL;
	double cost;
	ProposedMgdLeg *legP=NULL;
	const time_t longRestTm =  Minute*(optParam.minRestTm + optParam.postFlightTm + optParam.preFlightTm) ;

	_ASSERTE( numAircraft > 0 && numCrew > 0 && *cpAcStartInfosP == NULL && *numStartInfoP == 0 );

//////////////////////////////////////////////////////////////////////////////////////////////////////////allocate and initialize available pilots and acs
	if (!(availAcs = (DL_AvailInfo *) calloc (numAircraft, sizeof (DL_AvailInfo))))
	{
		logMsg(dlFile,"%s Line %d: Out of Memory \n", __FILE__,__LINE__);
		exit(1);
	}
	if (!(availPilots = (DL_AvailInfo *) calloc (numCrew, sizeof (DL_AvailInfo))))
	{
		logMsg(dlFile,"%s Line %d: Out of Memory \n", __FILE__,__LINE__);
		exit(1);
	}
	for(i=0; i<numAircraft; i++)
	{
		availAcs[i].ind = i ;
		availAcs[i].day = -1 ;
	}
	for(i=0; i<numCrew; i++)
	{
		availPilots[i].ind = i ;
		availPilots[i].day = -1 ;
		availPilots[i].latestLegEndB4HTravel = crewList[i].tourEndTm - Minute*optParam.postFlightTm ; //initialize
	}


///////////////////////////////////////////////////////////////////////////////////////////////////////get available ac ( available to crew aircrafts )
	//assume order of legs: ac, then leg start time
	for(j = 0; j < numPropMgdLegs ; j ++)
		//j: last leg of this ac
		if( j == numPropMgdLegs - 1 || propMgdLegs[j+1].aircraftID != propMgdLegs[j].aircraftID)
		{
			day = timeToDay( propMgdLegs[j].schedOut );
			acInd = acIDToInd(propMgdLegs[j].aircraftID);

			availAcs[acInd].inLegs = 1;//ac used in legs(in solution)
			
			//setting ac available if crew tour is ending//not considering overtime to crew acs
			if( (crewList[crewPairList[propMgdLegs[j].crewPairInd].crewListInd[0]].endRegDay <= day
			|| crewList[crewPairList[propMgdLegs[j].crewPairInd].crewListInd[1]].endRegDay <= day )
			&& propMgdLegs[j].schedIn + Minute*optParam.turnTime + MinCrewInterval <= optParam.windowEnd )
			{
				availAcs[acInd].apt = propMgdLegs[j].schedInAptID ;
				availAcs[acInd].tm = propMgdLegs[j].schedIn + Minute*optParam.turnTime; //set time
				availAcs[acInd].availAfter = DL_AfterLeg ;
				availAcs[acInd].day = timeToDay(availAcs[acInd].tm) ;
			}
		}

	//ac available after app column
	for( j = 0; j < numDemand ; j ++ )
		//if maint/app is covered and ac not used in legs, then maint/app must be in either existing tours or app columns
		//there must be legs in ext tours --> this ac has been setted to be in-legs as above
		if( demandList[j].isAppoint && dlDemUsed[j] && !availAcs[demandList[j].acInd].inLegs
		&& availAcs[demandList[j].acInd].tm < inTimes[j] + Minute*demandList[j].turnTime ) //availACTm initialized to zero
		{
			//note: an app column may contains more than one maint/app
			acInd = demandList[j].acInd;
			availAcs[acInd].inLegs = 1;//set to be used in legs(in solution)

			if( inTimes[j] + Minute*demandList[j].turnTime + MinCrewInterval <= optParam.windowEnd )
			{
				availAcs[acInd].tm = inTimes[j] + Minute*demandList[j].turnTime ; //note: use inTimes[j]
				availAcs[acInd].apt = demandList[j].inAirportID ;
				availAcs[acInd].availAfter = DL_AfterAppCol ;
				availAcs[acInd].day = timeToDay(availAcs[acInd].tm) ;
			}
		}

	//conside ac not used in solution
	for( acInd = 0; acInd < numAircraft ; acInd ++)
		if( !availAcs[acInd].inLegs && acList[acInd].availDT + MinCrewInterval <= optParam.windowEnd )
		{
			_ASSERTE( availAcs[acInd].tm == 0 );
			availAcs[acInd].tm = acList[acInd].availDT ;
			availAcs[acInd].apt = acList[acInd].availAirportID ;
			availAcs[acInd].availAfter = DL_AfterAvail ;
			availAcs[acInd].day = timeToDay(availAcs[acInd].tm) ;
		} //else if( availAcs[acInd].tm )
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////end get available ac

//////////////////////////////////////////////////////////////////////////////////////////////////set start info for each opt tour, also set available pilots
	for(i=0; i < numCrewPairs; i ++)//set start info for each opt tour, also set available pilots
	{
		if( cpAcAssigns[i] == NULL )
			continue ;
		
		pInds[0] = crewPairList[i].crewListInd[0] ;//initialize
		pInds[1] = crewPairList[i].crewListInd[1] ;

		//generate the start info of tour of this cp
		infoP = allocAStartInfo(cpAcStartInfosP, numStartInfoP);

		//legStartDay: day of the first duty: cp day
		for( infoP->legStartDay=0; infoP->legStartDay < optParam.planningWindowDuration; (infoP->legStartDay) ++ )
			if( cpAcAssigns[i][infoP->legStartDay].numAc )
				break;

		//legEndDay: day of the last duty: cp day
		for( infoP->legEndDay=optParam.planningWindowDuration -1 ; infoP->legEndDay >= 0; (infoP->legEndDay) -- )
			if( cpAcAssigns[i][infoP->legEndDay].numAc )
				break;

		_ASSERTE( infoP->legStartDay < optParam.planningWindowDuration && infoP->legStartDay >= 0 && infoP->legEndDay >= infoP->legStartDay ) ;

		//temp holder //first and lasr leg of this cp
		firstLeg = cpAcAssigns[i][infoP->legStartDay].firstLegP ;
		lastLeg = cpAcAssigns[i][infoP->legEndDay].lastLegP ;

		//generate infoP
		infoP->acTypeInd = crewPairList[i].acTypeIndex ;
		infoP->type = ( firstLeg->leg->exgTour ? DL_FromExist : DL_FromNew ) ;
		infoP->firstLegStart = firstLeg->leg->schedOut ;
		infoP->cpInd = i ;
		
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////available ac info
		infoP->acAvail.ind = firstLeg->acInd ;//first ac
		infoP->acAvail.apt = firstLeg->leg->schedOutAptID ;
		//set ac available time before current cp tour, without considering maint/app
		if( firstLeg->prevAcLeg != NULL ) //the last leg of this ac before leg j
			infoP->acAvail.tm = firstLeg->prevAcLeg->leg->schedIn + Minute*optParam.turnTime ;
		else //not found
			infoP->acAvail.tm = acList[infoP->acAvail.ind].availDT ;

		//compare ac available time with covered maint/app that are after ac available and before first leg
		for( k= 0; k < numDemand; k ++ )
			if( demandList[k].isAppoint && dlDemUsed[k] && demandList[k].acInd == infoP->acAvail.ind 
			&& inTimes[k] + Minute*demandList[k].turnTime <= infoP->firstLegStart && inTimes[k] + Minute*demandList[k].turnTime  > infoP->acAvail.tm )
				infoP->acAvail.tm = inTimes[k] + Minute*demandList[k].turnTime;
		//day available
		infoP->acAvail.day = timeToDay(infoP->acAvail.tm) ;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////get lastPossibleDay
		if( lastLeg->nextAcLeg != NULL )  //ac will be used later
			infoP->lastPossibleDay = min( optParam.planningWindowDuration - 1, lastLeg->nextAcLeg->day ) ; //note: same day as the next ac leg
		else
			infoP->lastPossibleDay = optParam.planningWindowDuration - 1 ; 
		
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////available pilot info
		for( m=0; m < 2; m ++ )
		{
			if( lastLeg->nextPilotLegs[m] != NULL )
				n = min(crewList[pInds[m]].endRegDay, min( infoP->lastPossibleDay, lastLeg->nextPilotLegs[m]->day)) ; //note: same day as the next pilot leg
			else 
				n = min(crewList[pInds[m]].endRegDay, infoP->lastPossibleDay) ; 
			infoP->lastPossibleDay = max( n, infoP->legEndDay ) ;//may overtime to do the duty

			infoP->pilotAvail[m].ind = pInds[m] ;
			if( firstLeg->prevPilotLegs[m] != NULL ) //pilot has a leg before
			{
				// rest after previous leg
				infoP->pilotAvail[m].apt = firstLeg->prevPilotLegs[m]->leg->schedInAptID ;
				infoP->pilotAvail[m].tm = firstLeg->prevPilotLegs[m]->leg->schedIn + Minute*(optParam.postFlightTm + optParam.minRestTm); //after rest
				infoP->pilotAvail[m].status = PilotRestB4Leg ;
				infoP->pilotAvail[m].dutyStartTm = 0 ;
				infoP->pilotAvail[m].availAfter = DL_AfterLeg ;
			} else//available from start
			{
				infoP->pilotAvail[m].apt = crewList[pInds[m]].availAirportID ;
				infoP->pilotAvail[m].tm = crewList[pInds[m]].availDT ;
				infoP->pilotAvail[m].availAfter = DL_AfterAvail ;
				if( crewList[pInds[m]].activityCode )//was resting
				{
					infoP->pilotAvail[m].status = ( crewList[pInds[m]].activityCode == 1 ? PilotRestB4Leg : PilotRestB4FirstLeg ) ;
					infoP->pilotAvail[m].dutyStartTm = 0 ;
				} else
				{
					_ASSERTE( crewList[pInds[m]].dutyTime >= 0 
					&& crewList[pInds[m]].dutyTime <= getCurMaxDutyTm(0, crewList[pInds[m]].availDT, crewList[pInds[m]].availAirportID )) ;

					infoP->pilotAvail[m].status = PilotInDuty ;
					infoP->pilotAvail[m].dutyStartTm = crewList[pInds[m]].availDT - Minute*crewList[pInds[m]].dutyTime ;
				}
			}//end
			infoP->pilotAvail[m].day = timeToDay(infoP->pilotAvail[m].tm) ;
		}//end for( m=0; m < 2; m ++ )
		
		infoP->acCpDay = max(infoP->acAvail.day, max( infoP->pilotAvail[0].day, infoP->pilotAvail[1].day));
		infoP->acCpDay = ( infoP->acCpDay > infoP->legStartDay ? infoP->legStartDay : infoP->acCpDay ) ;//start time fixed


////////////////////////////////////////////////////////////////////////////////////////////////////////////set available pilots after current cp tour
		availPilots[pInds[1]].inLegs = availPilots[pInds[0]].inLegs = 1 ;

		for( m=0; m < 2; m ++ )//for each pilot
		{
///////////////////////////////////////////////////////////////////////////////////this is the last leg of this pilot and need to consider travelling back home
			//set latestLegEndB4HTravel in every case, becasue we will need it for both opt tours and new tours
			//initialized to be the tour end time - post flight time
			if( lastLeg->nextPilotLegs[m] == NULL && crewList[pInds[m]].endRegDay < optParam.planningWindowDuration )
			{
				_ASSERTE( availPilots[pInds[m]].latestLegEndB4HTravel == crewList[pInds[m]].tourEndTm - Minute*optParam.postFlightTm );
				if( lastLeg->leg->schedInAptID != crewList[pInds[m]].endLoc )//travel non-trivial
				{
					//check whether feasible to travel home
					if( lastLeg->leg->schedIn + Minute*optParam.postFlightTm < crewList[pInds[m]].tourEndTm + DayInSecs*crewList[pInds[m]].stayLate
					&& !getCrewTravelDataLate(lastLeg->leg->schedIn + Minute*optParam.postFlightTm
					, (time_t)(crewList[pInds[m]].tourEndTm + DayInSecs*crewList[pInds[m]].stayLate)
					, lastLeg->leg->schedInAptID, crewList[pInds[m]].endLoc, &departTm, &dutyStartTm, &arrivalTm, &cost, withOag ))
						availPilots[pInds[m]].latestLegEndB4HTravel = max(lastLeg->leg->schedIn, min(departTm, crewList[pInds[m]].tourEndTm) - Minute*optParam.postFlightTm) ;
					else
						availPilots[pInds[m]].latestLegEndB4HTravel = lastLeg->leg->schedIn ; //infeasible, fix end time, pilot will not be available
				} else
					availPilots[pInds[m]].latestLegEndB4HTravel = max(lastLeg->leg->schedIn, crewList[pInds[m]].tourEndTm - Minute*optParam.postFlightTm ) ;
				
				_ASSERTE( availPilots[pInds[m]].latestLegEndB4HTravel >= lastLeg->leg->schedIn );
			}
		}

		//A pilot is not available in the following cases:
		//(1): crew pair and ac are not used later, and no long maintenance after this tour
		//check case (1)
		if( lastLeg->nextPilotLegs[0] == NULL && lastLeg->nextPilotLegs[1] == NULL && lastLeg->nextAcLeg == NULL )
		{
			for( n=0; n < numLongMaint; n ++)//check long maintenance
			{
				_ASSERTE( outTimes[longMaint[n]] > 0 ) ;
				//there is long maint after leg j and (no more legs of this ac, or long maint ends before the next leg of this ac) 
				if( demandList[longMaint[n]].acInd == infoP->acAvail.ind && outTimes[longMaint[n]] >= lastLeg->leg->schedIn )
					break ;
			}
			if(  n >= numLongMaint ) //no long maintenance for this ac
				continue ; //pilots not available
		}//end if

		//(2): pilot is used later/tour end/after rest availabel out of window
		for( m=0; m < 2; m ++ )//for each pilot
		{
			if( infoP->legEndDay == optParam.planningWindowDuration - 1 //next day is out of planning horizon, no need to check further, pilot not available
			|| crewList[pInds[m]].endRegDay <= infoP->legEndDay //if tour ends, then not available (no overtime)
			//if this pilot is used on later days: not setting this pilot to pair with other pilots, i.e. only consider current pair and the next pair
			|| lastLeg->nextPilotLegs[m] != NULL
			|| optParam.windowEnd < lastLeg->leg->schedIn + longRestTm + MinCrewInterval
			|| availPilots[pInds[m]].latestLegEndB4HTravel < lastLeg->leg->schedIn + longRestTm + MinCrewInterval )
				continue ; //pilot m not available

			_ASSERTE(availPilots[pInds[m]].ind == pInds[m] && availPilots[pInds[m]].apt == 0 && availPilots[pInds[m]].tm == 0 ) ;

			availPilots[pInds[m]].apt = lastLeg->leg->schedInAptID ;
			//set pilot to be available after rest //available to pair with other pilots; earliest available time
			availPilots[pInds[m]].tm = lastLeg->leg->schedIn + Minute*(optParam.minRestTm + optParam.postFlightTm) ;
			//available on the next day
			availPilots[pInds[m]].day = max( infoP->legEndDay + 1, timeToDay(availPilots[pInds[m]].tm) ) ;
			availPilots[pInds[m]].availAfter = DL_AfterLeg ;
			availPilots[pInds[m]].status = PilotRestB4Leg ;
			availPilots[pInds[m]].dutyStartTm = 0 ;
		}//end for( m=0; m < 2; m ++ )
	}//end for(i=0; i < numCrewPairs; i ++)

	
///////////////////////////////////////////////////////////////////////////////////////////////for each originally available pilot, get the available info
	for(i=0; i < numCrew; i++)
		if( !availPilots[i].inLegs && crewList[i].availDT + MinCrewInterval <= optParam.windowEnd 
		&& crewList[i].availDT + Minute*optParam.preFlightTm + MinCrewInterval <= crewList[i].tourEndTm - Minute*optParam.postFlightTm ) //no overtime to crew ac  //A1
		{
			_ASSERTE( availPilots[i].latestLegEndB4HTravel == crewList[i].tourEndTm - Minute*optParam.postFlightTm );
			//set the tour end time for each pilot, if a pilot needs to travel home
			if( crewList[i].endRegDay < optParam.planningWindowDuration && crewList[i].availAirportID != crewList[i].endLoc ) //consider travelling back home
			{
				//whether feasible to travel home
				if ( !getCrewTravelDataLate(crewList[i].availDT, (time_t)(crewList[i].tourEndTm + DayInSecs*crewList[i].stayLate)
				, crewList[i].availAirportID, crewList[i].endLoc, &departTm, &dutyStartTm, &arrivalTm, &cost, withOag )
				&& crewList[i].availDT + Minute*optParam.preFlightTm + MinCrewInterval <= dutyStartTm - Minute*optParam.postFlightTm )//enough time to crew ac
					availPilots[i].latestLegEndB4HTravel = min(crewList[i].tourEndTm, dutyStartTm) - Minute*optParam.postFlightTm ;
				else
					continue ;//not available
			}

			availPilots[i].tm = crewList[i].availDT ;
			availPilots[i].apt = crewList[i].availAirportID ;
			availPilots[i].day = timeToDay(crewList[i].availDT);
			availPilots[i].availAfter = DL_AfterAvail ;
			if( crewList[i].activityCode )//was resting
			{
				availPilots[i].status = (crewList[i].activityCode == 1 ? PilotRestB4Leg : PilotRestB4FirstLeg ) ;
				availPilots[i].dutyStartTm = 0 ;
			} else
			{
				availPilots[i].status = PilotInDuty ;
				availPilots[i].dutyStartTm = crewList[i].availDT - Minute*crewList[i].dutyTime ;
			}
		}
	
	for(i=0; i < numCrewPairs; i ++)//////////////////////////////////////////////////////////////////////////////set start info for each available cp and ac
	{
		pInds[0] = crewPairList[i].crewListInd[0] ;//initialize
		pInds[1] = crewPairList[i].crewListInd[1] ;

		//if one pilot is in the solution, but not setted to be available per above, then this crew pair is not available
		if( !availPilots[pInds[0]].tm || !availPilots[pInds[1]].tm )
			continue ;

		_ASSERTE( availPilots[pInds[0]].day >= 0 && availPilots[pInds[1]].day >= 0 
		&& availPilots[pInds[0]].latestLegEndB4HTravel >= availPilots[pInds[0]].tm + Minute*optParam.preFlightTm + MinCrewInterval
		&& availPilots[pInds[1]].latestLegEndB4HTravel >= availPilots[pInds[1]].tm + Minute*optParam.preFlightTm + MinCrewInterval
		&& availPilots[pInds[0]].tm + MinCrewInterval <= optParam.windowEnd && availPilots[pInds[1]].tm + MinCrewInterval <= optParam.windowEnd );

		for(acInd=0; acInd < numAircraft; acInd ++)
		{
			if(acList[acInd].acTypeIndex != crewPairList[i].acTypeIndex || !availAcs[acInd].tm ) 
				continue;

			_ASSERTE( availAcs[acInd].tm + MinCrewInterval <= optParam.windowEnd );

			//check tour end time
			tempTm = MinCrewInterval + max(availAcs[acInd].tm, max(availPilots[pInds[0]].tm, availPilots[pInds[1]].tm)); //check ac/cp available time
			if( availPilots[pInds[0]].latestLegEndB4HTravel < tempTm || availPilots[pInds[1]].latestLegEndB4HTravel < tempTm )
				continue;

			//check days
			day = max(availAcs[acInd].day, max( availPilots[pInds[0]].day, availPilots[pInds[1]].day ));
			if( crewList[pInds[0]].endRegDay < day || crewList[pInds[1]].endRegDay < day )
				continue;
			_ASSERTE( day >= 0 && day < optParam.planningWindowDuration ) ;

			infoP = allocAStartInfo(cpAcStartInfosP, numStartInfoP);//allocate

			memmove(&(infoP->acAvail), &(availAcs[acInd]), sizeof(DL_AvailInfo));
			memmove(&(infoP->pilotAvail[0]), &(availPilots[pInds[0]]), sizeof(DL_AvailInfo));
			memmove(&(infoP->pilotAvail[1]), &(availPilots[pInds[1]]), sizeof(DL_AvailInfo));

			infoP->acTypeInd = acList[acInd].acTypeIndex ;
			infoP->cpInd = i ;
			infoP->firstLegStart = 0 ;
			infoP->type =  DL_NewAvail ;

			infoP->acCpDay = day ;
			infoP->lastPossibleDay = min(optParam.planningWindowDuration - 1, min( crewList[pInds[0]].endRegDay, crewList[pInds[1]].endRegDay));
			infoP->legStartDay = infoP->legEndDay = infoP->lastPossibleDay ; //note
		}//for(acInd=0; acInd < numAircraft; acInd ++)
	}//for(i=0; i < numCrewPairs; i ++)

	//firstLegStart, acInd, cpInd
	qsort( (*cpAcStartInfosP), (*numStartInfoP), sizeof(DL_CpAcStartInfo), compareCpAcStartInfo);

/////////////////////////////////////////////////////////////////////////////////////////////////////generate the next pointer, to opt tours, in opt tours
	for(i=0; i < *numStartInfoP; i ++)
	{
		(*cpAcStartInfosP)[i].index = i ; //index

		if( (*cpAcStartInfosP)[i].type == DL_NewAvail )
			continue ;

		if( !(*cpAcStartInfosP)[i].acNext ) //pointer not generated yet
			for(j=i+1; j < *numStartInfoP; j ++)//go through, sorted
				if( (*cpAcStartInfosP)[j].acAvail.ind == (*cpAcStartInfosP)[i].acAvail.ind ) //same ac
				{
					_ASSERTE( (*cpAcStartInfosP)[j].type != DL_NewAvail );
					(*cpAcStartInfosP)[i].acNext = &((*cpAcStartInfosP)[j]) ;
					break;					
				}

		for(k=0; k < 2; k++)//for each pilot
		{
			if( (*cpAcStartInfosP)[i].pilotNext[k] )//has generated
				continue ;

			for(j=i+1; j < *numStartInfoP; j ++)//go through, sorted
				if(  (*cpAcStartInfosP)[j].pilotAvail[0].ind == (*cpAcStartInfosP)[i].pilotAvail[k].ind 
				||  (*cpAcStartInfosP)[j].pilotAvail[1].ind == (*cpAcStartInfosP)[i].pilotAvail[k].ind )
				{
					_ASSERTE( (*cpAcStartInfosP)[j].type != DL_NewAvail );
					(*cpAcStartInfosP)[i].pilotNext[k] = &((*cpAcStartInfosP)[j]) ;
					break;
				}
		}//end for(k=0; k < 2; k++)
	}//end

	//return
	*availAcsP = availAcs;
	*availPilotsP = availPilots;

	return 0;
}

/*
//get the last possible day
static int getLatestDay( const int day, const PilotAcAssign **pilotAcAssigns, DL_CpAcStartInfo *infoP )
{
	int m, k, n ;

	for(m= day+1; m < optParam.planningWindowDuration; m ++ )
	{
		//tour end, not considering overtime
		if( crewList[infoP->pilotAvail[0].ind].endRegDay <= m || crewList[infoP->pilotAvail[1].ind].endRegDay <= m )
			break;

		//pilot assigned on current day (must to another ac), stop
		if( pilotAcAssigns[infoP->pilotAvail[0].ind][m].crewStartTm > 0 || pilotAcAssigns[infoP->pilotAvail[1].ind][m].crewStartTm  > 0 )
			break; 

		//ac is used by another pilot, stop
		for( k =0; k < numCrew; k ++ )
			if( pilotAcAssigns[k] != NULL && pilotAcAssigns[k][m].crewStartTm > 0 )
			{
				for( n = 0; n < DL_MAX_NUM_AC_PER_DUTY; n ++ )
					if( pilotAcAssigns[k][m].acInd[n] == infoP->acAvail.ind )
						break;
				if(n < DL_MAX_NUM_AC_PER_DUTY)
					break;
			}
		if( k < numCrew )
			break;
	}

	infoP->lastPossibleDay = m - 1 ;
	return 0 ;
}
*/

static int generateLongMaintlInfo(const DL_DemUsedType *dlDemUsed, int **longMaintP, int *numLongMaintP)
{
	int i, count, *longMaint, numLongMaint ;

	count = 0;
	for( i = 0; i < numDemand; i ++)
		if( demandList[i].isAppoint && dlDemUsed[i] && demandList[i].reqIn - demandList[i].reqOut >= Minute*optParam.maintTmForReassign)
			count ++ ;

	if( count )
	{
		if(!( longMaint = (int *) calloc ( count, sizeof (int) )))
		{
			logMsg(dlFile,"%s Line %d: Out of Memory.\n", __FILE__,__LINE__);
			exit(1);
		}

		numLongMaint = count;

		count = 0;
		for( i = 0; i < numDemand; i ++)
			if( demandList[i].isAppoint && dlDemUsed[i] && demandList[i].reqIn - demandList[i].reqOut >= Minute*optParam.maintTmForReassign)
			{
				longMaint[count] = i ;
				count ++ ;
			}
		_ASSERTE( count == numLongMaint);

		*longMaintP = longMaint ;
		*numLongMaintP = numLongMaint ;
	} else
	{
		*longMaintP = NULL ;
		*numLongMaintP = 0 ;
	}

	return 0;
}

static int generateLegsCP( DL_LegInfo **legInfosCPP )
{
	int i, j, m, ind, prevInd ;
	DL_LegInfo *legInfosCP;//temp
	const time_t longRestTm =  Minute*(optParam.minRestTm + optParam.postFlightTm + optParam.preFlightTm) ;

	//sort in order of ac
	qsort((void *) propMgdLegs, numPropMgdLegs, sizeof(ProposedMgdLeg), compareMgdLegsAC);

///////////////////////////////////////////////////////////////////////////////////////consider the case where a repo leg is skipped in the exg tour
	for( i = 0; i < numPropMgdLegs; i ++ )
		if(i == 0 || propMgdLegs[i].aircraftID != propMgdLegs[i-1].aircraftID )
		{
			ind = acIDToInd(propMgdLegs[i].aircraftID);
			if( acList[ind].availAirportID != propMgdLegs[i].schedOutAptID )
			{
				_ASSERTE( propMgdLegs[i].exgTour );
				acList[ind].availAirportID = propMgdLegs[i].schedOutAptID ;
				fprintf(dlFile, "\n Warning: aircraft %d available location updated \n", propMgdLegs[i].aircraftID );
			}
		}
///////////////////////////////////////////////////////////////////////////////////////consider the case where a repo leg is skipped in the exg tour

	if (!(legInfosCP = (DL_LegInfo *) calloc (numPropMgdLegs, sizeof (DL_LegInfo))))
	{
		logMsg(dlFile,"%s Line %d: Out of Memory \n", __FILE__,__LINE__);
		exit(1);
	}

	for( i = 0; i < numPropMgdLegs; i ++ )
	{
		legInfosCP[i].leg = &(propMgdLegs[i]) ;
		legInfosCP[i].legInd = i ;//index in propMgdLegs
		legInfosCP[i].day = -1 ; //cp day
		legInfosCP[i].schInDay = timeToDay(propMgdLegs[i].schedIn);
		legInfosCP[i].schOutDay = timeToDay(propMgdLegs[i].schedOut);
		legInfosCP[i].acInd = acIDToInd(propMgdLegs[i].aircraftID) ;//ac ind
	}

	//increasing order of crew pair, then out time
	qsort((void *) legInfosCP, numPropMgdLegs, sizeof(DL_LegInfo), compareLegInfoCP);

	for( i = 0; i < numPropMgdLegs; i ++ )
	{
		legInfosCP[i].legIndCP = i ;

		////////////////////////////////////////////get previous leg with the same ac
		_ASSERTE( legInfosCP[i].prevAcLeg == NULL &&  legInfosCP[i].prevPilotLegs[0] == NULL && legInfosCP[i].prevPilotLegs[1] == NULL );
			
		prevInd = -1 ;//previous leg with the same ac
		for(j=numPropMgdLegs-1; j >= 0; j --) //go through each leg
			if(legInfosCP[j].acInd == legInfosCP[i].acInd && legInfosCP[j].leg->schedOut < legInfosCP[i].leg->schedOut
			&& (prevInd == -1 || legInfosCP[j].leg->schedIn > legInfosCP[prevInd].leg->schedIn ))
				prevInd = j ;

		if( prevInd >= 0 )//found
		{
			_ASSERTE( legInfosCP[prevInd].nextAcLeg == NULL && legInfosCP[prevInd].noAcTurn[1] == 0 ) ;

			legInfosCP[i].prevAcLeg = &(legInfosCP[prevInd]) ; //update
			legInfosCP[prevInd].nextAcLeg = &(legInfosCP[i]) ;  

			if( legInfosCP[prevInd].leg->schedIn + Minute*optParam.turnTime > legInfosCP[i].leg->schedOut )
			{
				legInfosCP[prevInd].noAcTurn[1] = 1; //no enough turn time at the end
				legInfosCP[i].noAcTurn[0] = 1;//no enough turn time at the begining
			}
		}
		////////////////////////////////////////////get previous leg with the same ac

		////////////////////////////////////////////get previous leg with the same pilot
		for(m=0; m < 2; m ++)
		{
			ind = crewPairList[legInfosCP[i].leg->crewPairInd].crewListInd[m] ;//pilot index

			//if( crewList[ind].availDT >  propMgdLegs[i].schedOut )
			//	legInfosCP[i].noPilotRest[m][0] = 1;

			prevInd = -1 ;//previous leg with the same pilot
			for(j=numPropMgdLegs-1; j >= 0; j --) //go through each leg
				if( ( legInfosCP[j].leg->captainID == crewList[ind].crewID || legInfosCP[j].leg->FOID == crewList[ind].crewID) 
				&& legInfosCP[j].leg->schedOut < legInfosCP[i].leg->schedOut 
				&& (prevInd == -1 || legInfosCP[j].leg->schedIn > legInfosCP[prevInd].leg->schedIn ) )
					prevInd = j ;
			
			if( prevInd >= 0 )//found
			{
				legInfosCP[i].prevPilotLegs[m] = &(legInfosCP[prevInd]) ;//update
				
				j =  (legInfosCP[prevInd].leg->captainID == crewList[ind].crewID ? 0 : 1 ); //get the index

				_ASSERTE( legInfosCP[prevInd].nextPilotLegs[j] == NULL && legInfosCP[prevInd].noPilotRest[j][1] == 0 ) ;
				
				legInfosCP[prevInd].nextPilotLegs[j] = &(legInfosCP[i]);

				if( legInfosCP[prevInd].leg->schedIn + longRestTm > legInfosCP[i].leg->schedOut )
				{
					legInfosCP[prevInd].noPilotRest[j][1] = 1 ;//no enough rest time at the end
					legInfosCP[i].noPilotRest[m][0] = 1 ;//no enough rest time at the end
				}
			}//end if( prevInd >= 0 )
		}//end for(m=0; m < 2; m ++)
	}//end for( i = 0; i < numPropMgdLegs; i ++ )

	*legInfosCPP = legInfosCP ;
	return 0 ;
}

static int printLongMaintlInfo(const int *longMaint, const int numLongMaint)
{
	char opbuf1[1024], opbuf2[1024], opbuf3[1024];
	DateTime dt1, dt2, dt3;
	int i, j;

	fprintf (dlFile, " \n\n--> long maint :\n");
	fprintf (dlFile, "+------------+------------+------------+------------+------------+------------+-----------------+-----------------+------------------+------------------+------------------+\n");
	fprintf (dlFile, "| DemandID   | Early Adj  | Late Adj   | AC ID      | Hard Incl  | Orig ID    | Default Airport | Actual Airport  | Default Out Time | Req Out Time     | Actual Time      |\n");
	fprintf (dlFile, "+------------+------------+------------+------------+------------+------------+-----------------+-----------------+------------------+------------------+------------------+\n");

	for (j=0; j<numLongMaint; j++)
	{	
		i = longMaint[j] ;

		if( optParam.withFlexOS)
			dt1 = dt_time_tToDateTime (origDemInfos[demandList[i].origDemInd].defaultOut);
		else
			dt1 = dt_time_tToDateTime (demandList[i].reqOut);

		dt2 = dt_time_tToDateTime (demandList[i].reqOut);
		dt3 = ( outTimes[i] == 0 ? 0 : dt_time_tToDateTime (outTimes[i])) ;

		fprintf (dlFile, "| %10d |   %6d   |   %6d   |   %6d   |   %6d   | %10d |   %10d    |   %10d    | %16s | %16s | %16s |\n",
					demandList[i].demandID, 
					demandList[i].earlyAdj, 
					demandList[i].lateAdj,
					demandList[i].aircraftID,
					1-demandList[i].skipIncl,
					demandList[i].origUniqueID,
					demandList[i].outAirportID,
					demandList[i].outAirportID,
					dt_DateTimeToDateTimeString(dt1, opbuf1, "%Y/%m/%d %H:%M"),
					dt_DateTimeToDateTimeString(dt2, opbuf2, "%Y/%m/%d %H:%M"),
					(dt3 == 0 ? "Not in new tours" : dt_DateTimeToDateTimeString(dt3, opbuf3, "%Y/%m/%d %H:%M")));
	}
	fprintf (dlFile, "+------------+------------+------------+------------+------------+------------+-----------------+-----------------+------------------+------------------+------------------+\n");

	return 0 ;
}


static int printCurrentCpDutyAssign(const DL_CpAcAssign **cpAcAssigns)
{
	int i, j, day;

	fprintf (dlFile, "\n\n--> current crewpair aircraft assignments :\n");

	for (j=0; j< numCrewPairs; j++)
	{	
		fprintf(dlFile, "\n--> crew pair %d: %d, %d : \n", j, crewPairList[j].captainID, crewPairList[j].flightOffID) ;

		if( cpAcAssigns[j] == NULL )
			continue;

		fprintf (dlFile, "+------------+------------+------------+------------+------------+------------+------------+------------+------------+------------+------------+------------+------------+");
		for(i=0; i < DL_MAX_NUM_AC_PER_DUTY; i ++)
			fprintf (dlFile, "------------+------------+");
		fprintf (dlFile, "\n" );

		fprintf (dlFile, "| Day        | DutyNum    | FirstLeg   | LastLeg    | PrevAcLeg  | NextAcLeg  | PrevPtLeg0 | PrevPtLeg1 | NextPtLeg0 | NextPtLeg1 | StartTmFix | EndTmFix   | DL_FExist  |");
		for(i=0; i < DL_MAX_NUM_AC_PER_DUTY; i ++)
			fprintf (dlFile, " AssignAcID | AcEndLeg   |");
		fprintf (dlFile, "\n" );


		fprintf (dlFile, "+------------+------------+------------+------------+------------+------------+------------+------------+------------+------------+------------+------------+------------+");
		for(i=0; i < DL_MAX_NUM_AC_PER_DUTY; i ++)
			fprintf (dlFile, "------------+------------+");
		fprintf (dlFile, "\n" );

		for( day=0; day < optParam.planningWindowDuration; day ++ )
		{
			const DL_CpAcAssign *inP = &(cpAcAssigns[j][day]) ;

			if( !inP->numAc )
				continue ;
			
			fprintf (dlFile, "| %10d | %10d | %10d | %10d | %10d | %10d | %10d | %10d | %10d | %10d | %10d | %10d | %10d |"
			, day, inP->dutyNum, inP->firstLegP->legIndCP, inP->lastLegP->legIndCP
			, ( inP->firstLegP->prevAcLeg == NULL ? -1 : inP->firstLegP->prevAcLeg->legIndCP ) 
			, ( inP->lastLegP->nextAcLeg == NULL ? -1 : inP->lastLegP->nextAcLeg->legIndCP )
			, ( inP->firstLegP->prevPilotLegs[0] == NULL ? -1 : inP->firstLegP->prevPilotLegs[0]->legIndCP )
			, ( inP->firstLegP->prevPilotLegs[1] == NULL ? -1 : inP->firstLegP->prevPilotLegs[1]->legIndCP )
			, ( inP->lastLegP->nextPilotLegs[0] == NULL ? -1 : inP->lastLegP->nextPilotLegs[0]->legIndCP )
			, ( inP->lastLegP->nextPilotLegs[1] == NULL ? -1 : inP->lastLegP->nextPilotLegs[1]->legIndCP )
			, inP->tmFixed, inP->tmFixed, inP->tmFixed ) ;

			for(i=0; i < DL_MAX_NUM_AC_PER_DUTY; i ++)
				if( inP->acInd[i] >= 0 )
					fprintf (dlFile, " %10d | %10d |", acList[inP->acInd[i]].aircraftID, inP->acEndLeg[i] );
				else
					fprintf (dlFile, "            |            |") ;

			fprintf (dlFile, "\n" );

			fprintf (dlFile, "+------------+------------+------------+------------+------------+------------+------------+------------+------------+------------+------------+------------+------------+");
			for(i=0; i < DL_MAX_NUM_AC_PER_DUTY; i ++)
				fprintf (dlFile, "------------+------------+");
			fprintf (dlFile, "\n" );
		}
	}
	return 0 ;
}

static int printCpAcStartInfo( const DL_CpAcStartInfo *cpAcStartInfos, const int numStartInfo, const DL_AvailInfo *availAcs, const DL_AvailInfo *availPilots)
{
	char opbuf1[1024], opbuf2[1024], opbuf3[1024], opbuf4[1024];
	int j, count, temp = 0;

	fprintf (dlFile, "\n\n --> available acs:\n");
	fprintf (dlFile, "+------------+------------+------------+------------+------------+------------+------------------+ \n");
	fprintf (dlFile, "| Ac Ind     | Ac ID      | In Legs    | Avail Apt  | Avail Aftr | Avail Day  | Ac Available Tm  | \n");
	fprintf (dlFile, "+------------+------------+------------+------------+------------+------------+------------------+ \n");

	for(j=0; j < numAircraft; j ++)
	{
		fprintf (dlFile, "| %10d | %10d | %10d | %10d | %10d | %10d | %16s | \n"
		, availAcs[j].ind, acList[availAcs[j].ind].aircraftID, availAcs[j].inLegs, availAcs[j].apt, availAcs[j].availAfter, availAcs[j].day
		, ( !availAcs[j].tm ? " " : dt_DateTimeToDateTimeString(dt_time_tToDateTime (availAcs[j].tm), opbuf1, "%Y/%m/%d %H:%M")) );
		fprintf (dlFile, "+------------+------------+------------+------------+------------+------------+------------------+ \n");
	}

	fprintf (dlFile, "\n\n --> available pilots:\n");
	fprintf (dlFile, "+------------+------------+------------+------------+------------+------------+------------+------------------+------------------+------------------+------------------+ \n");
	fprintf (dlFile, "| Pilot Ind  | Pilot ID   | In Legs    | Avail Stus | Avail Apt  | Avail Aftr | Avail Day  | Available Tm     | Duty Start Tm    | Latest Duty End  | Tour End Time    | \n");
	fprintf (dlFile, "+------------+------------+------------+------------+------------+------------+------------+------------------+------------------+------------------+------------------+ \n");

	for(j=0; j < numCrew; j ++)
	{
		fprintf (dlFile, "| %10d | %10d | %10d | %10d | %10d | %10d | %10d | %16s | %16s | %16s | %16s | \n"
		, availPilots[j].ind, crewList[availPilots[j].ind].crewID, availPilots[j].inLegs, availPilots[j].status,  availPilots[j].apt, availPilots[j].availAfter, availPilots[j].day
		, ( !availPilots[j].tm ? " " : dt_DateTimeToDateTimeString(dt_time_tToDateTime (availPilots[j].tm), opbuf1, "%Y/%m/%d %H:%M"))
		, ( !availPilots[j].dutyStartTm ? " " : dt_DateTimeToDateTimeString(dt_time_tToDateTime (availPilots[j].dutyStartTm), opbuf2, "%Y/%m/%d %H:%M"))
		, ( !availPilots[j].latestLegEndB4HTravel ? " " : dt_DateTimeToDateTimeString(dt_time_tToDateTime (availPilots[j].latestLegEndB4HTravel), opbuf3, "%Y/%m/%d %H:%M"))
		,  ( !crewList[j].tourEndTm ? " " : dt_DateTimeToDateTimeString(dt_time_tToDateTime (crewList[j].tourEndTm), opbuf4, "%Y/%m/%d %H:%M"))
		);
		fprintf (dlFile, "+------------+------------+------------+------------+------------+------------+------------+------------------+------------------+------------------+------------------+ \n");
	}


	fprintf (dlFile, "\n\n --> crewpair aircraft start info:\n");
	fprintf (dlFile, "+------------------+------------+------------+------------+------------+------------+------------+------------+------------+------------+------------------+------------+------------+------------+------------------+------------+------------+------------+------------------+ \n");
	fprintf (dlFile, "| First Leg Start  | Tour Ind   | Tour Type  | Fleet Type | Ac Cp Day  | First Day  | Last Day   | Last P Day | Ac ID      | Ac Airport | Ac Available Tm  | P0 ID      | P0 Status  | P0 Airport | P0 Available Tm  | P1 ID      | P1 Status  | P1 Airport | P1 Available Tm  | \n");
	fprintf (dlFile, "+------------------+------------+------------+------------+------------+------------+------------+------------+------------+------------+------------------+------------+------------+------------+------------------+------------+------------+------------+------------------+ \n");

	count = 0; 
	for (j=0; j< numStartInfo; j++)
	{	
		const DL_CpAcStartInfo *inP = &(cpAcStartInfos[j]) ;

		fprintf (dlFile, "| %16s | %10d | %10d | %10d | %10d | %10d | %10d | %10d | %10d | %10d | %16s | %10d | %10d | %10d | %16s | %10d | %10d | %10d | %16s | \n"
		, ( !inP->firstLegStart ? " " : dt_DateTimeToDateTimeString(dt_time_tToDateTime (inP->firstLegStart), opbuf1, "%Y/%m/%d %H:%M"))
		, j, inP->type, inP->acTypeInd, inP->acCpDay, inP->legStartDay, inP->legEndDay, inP->lastPossibleDay, acList[inP->acAvail.ind].aircraftID, inP->acAvail.apt
		, ( !inP->acAvail.tm ? " " : dt_DateTimeToDateTimeString(dt_time_tToDateTime (inP->acAvail.tm), opbuf2, "%Y/%m/%d %H:%M"))
		, crewPairList[inP->cpInd].captainID, inP->pilotAvail[0].status, inP->pilotAvail[0].apt
		, ( !inP->pilotAvail[0].tm ? " " : dt_DateTimeToDateTimeString(dt_time_tToDateTime (inP->pilotAvail[0].tm), opbuf3, "%Y/%m/%d %H:%M"))
		, crewPairList[inP->cpInd].flightOffID, inP->pilotAvail[1].status, inP->pilotAvail[1].apt
		, ( !inP->pilotAvail[1].tm ? " " : dt_DateTimeToDateTimeString(dt_time_tToDateTime (inP->pilotAvail[1].tm), opbuf4, "%Y/%m/%d %H:%M"))) ;

		if( count && !(count%25) )
		{
			fprintf (dlFile, "+------------------+------------+------------+------------+------------+------------+------------+------------+------------+------------+------------------+------------+------------+------------+------------------+------------+------------+------------+------------------+ \n");
			fprintf (dlFile, "| First Leg Start  | Tour Ind   | Tour Type  | Fleet Type | Ac Cp Day  | First Day  | Last Day   | Last P Day | Ac ID      | Ac Airport | Ac Available Tm  | P0 ID      | P0 Status  | P0 Airport | P0 Available Tm  | P1 ID      | P1 Status  | P1 Airport | P1 Available Tm  | \n");
			fprintf (dlFile, "+------------------+------------+------------+------------+------------+------------+------------+------------+------------+------------+------------------+------------+------------+------------+------------------+------------+------------+------------+------------------+ \n");
		} else
			fprintf (dlFile, "+------------------+------------+------------+------------+------------+------------+------------+------------+------------+------------+------------------+------------+------------+------------+------------------+------------+------------+------------+------------------+ \n");
		count ++;
	}

	return 0;
}

static int printNewAssigns( const DL_Column ****newAssigns, const int ***numNewAssigns, const int numStartInfo)
{
	char opbuf1[1024], opbuf2[1024], opbuf3[1024], opbuf4[1024], opbuf5[1024], opbuf6[1024], opbuf7[1024];
	int i, j, k, m ;

	fprintf (dlFile, "\n\n --> All columns:\n");

	for(i=0; i < numStartInfo ; i ++)
	{
		for(j=0; j < optParam.planningWindowDuration; j ++)
		{
			if( !newAssigns[i][j] )
				continue;

			fprintf (dlFile, "+------------+------------+------------+------------+------------+------------+------------------+------------+------------------+------------+------------------+------------------+------------------+------------------+------------------+------------+------------+ \n");
			fprintf (dlFile, "| Day        | First Day  | Keep Orig  | Crew Pair  | Aircraft   | Ac Airport | Ac Avail Tm      | P0 Airport | P0 Avail Tm      | P1 Airport | P1 Avail Tm      | P0 Start Time    | P1 Start Time    | Start Time       | End Time         | Cost       | # Cvd Dems | \n");
			fprintf (dlFile, "+------------+------------+------------+------------+------------+------------+------------------+------------+------------------+------------+------------------+------------------+------------------+------------------+------------------+------------+------------+ \n");

			for(k=0; k<2; k++)
			{
				if( !newAssigns[i][j][k] )
					continue;

				for(m=0; m < numNewAssigns[i][j][k]; m ++)
				{
					const DL_Column *inP = &(newAssigns[i][j][k][m]) ;

					fprintf (dlFile, "| %10d | %10d | %10d | %10d | %10d | %10d | %16s | %10d | %16s | %10d | %16s | %16s | %16s | %16s | %16s | %10.2f | %10d | \n"
					, inP->day, inP->firstDay, inP->keepOriginal, inP->startInfoP->cpInd, acList[inP->startInfoP->acAvail.ind].aircraftID, inP->acAirport
					, ( !inP->acTm ? " " : dt_DateTimeToDateTimeString(dt_time_tToDateTime (inP->acTm), opbuf1, "%Y/%m/%d %H:%M"))
					, inP->pAirports[0]
					, ( !inP->pTm[0] ? " " : dt_DateTimeToDateTimeString(dt_time_tToDateTime (inP->pTm[0]), opbuf2, "%Y/%m/%d %H:%M"))
					, inP->pAirports[1]
					, ( !inP->pTm[1] ? " " : dt_DateTimeToDateTimeString(dt_time_tToDateTime (inP->pTm[1]), opbuf3, "%Y/%m/%d %H:%M"))
					, ( !inP->pilotStartTm[0] ? " " : dt_DateTimeToDateTimeString(dt_time_tToDateTime (inP->pilotStartTm[0]), opbuf4, "%Y/%m/%d %H:%M"))
					, ( !inP->pilotStartTm[1] ? " " : dt_DateTimeToDateTimeString(dt_time_tToDateTime (inP->pilotStartTm[1]), opbuf5, "%Y/%m/%d %H:%M"))
					, ( !inP->startTm ? " " : dt_DateTimeToDateTimeString(dt_time_tToDateTime (inP->startTm), opbuf6, "%Y/%m/%d %H:%M"))
					, ( !inP->endTm ? " " : dt_DateTimeToDateTimeString(dt_time_tToDateTime (inP->endTm), opbuf7, "%Y/%m/%d %H:%M"))
					, inP->cost, inP->numCoverDems ) ;
				}//end 	for(m=0;
			}//end 	for(k=0;
		}//end 	for(j=0;
	}//end 	for(i=0;

	return 0;
}

static int checkCurrentCpDutyAssign(const DL_CpAcAssign **cpAcAssigns, const DL_LegInfo *legInfosCP)
{
	int i, j, m, day, index, cpInd, pilotInd[2], dutyNum, iPilotInd[2], jPilotInd[2] ;
	time_t tempTm;
	const time_t longRestTm =  Minute*(optParam.minRestTm + optParam.postFlightTm + optParam.preFlightTm) ;

	_ASSERTE( cpAcAssigns != NULL && legInfosCP != NULL );
	for (cpInd=0; cpInd < numCrewPairs; cpInd++)
	{	
		if( cpAcAssigns[cpInd] == NULL )
			continue;

		pilotInd[0] = crewPairList[cpInd].crewListInd[0] ;
		pilotInd[1] = crewPairList[cpInd].crewListInd[1] ;
		dutyNum = 0 ;

		for( day=0; day < optParam.planningWindowDuration; day ++ )
		{
			const DL_CpAcAssign *inP = &(cpAcAssigns[cpInd][day]) ; //initialize

			_ASSERTE( inP->numAc >= 0 );
			if( !inP->numAc ) //not assigned on this day
			{
				_ASSERTE( inP->dutyNum == 0 && inP->lastLegP == NULL && inP->firstLegP == NULL && inP->tmFixed == 0 && inP->numAc == 0);
				continue; 
			}

			_ASSERTE( inP->dutyNum == dutyNum && inP->lastLegP->legIndCP >= inP->firstLegP->legIndCP 
			&& inP->firstLegP->leg->crewPairInd == cpInd && inP->firstLegP->acInd == inP->acInd[0] 
			&& inP->lastLegP->schOutDay >= inP->firstLegP->schOutDay 
			&& ( day == inP->firstLegP->schOutDay || day == inP->firstLegP->schOutDay + 1) ) ;

			index = 0 ; //index for ac's in this duty
			for( i = inP->firstLegP->legIndCP; i < inP->lastLegP->legIndCP; i ++)
			{
				_ASSERTE( legInfosCP[i].leg->crewPairInd == legInfosCP[i+1].leg->crewPairInd && legInfosCP[i].leg->schedIn <= legInfosCP[i+1].leg->schedOut
				&& inP->acInd[index] >= 0 && legInfosCP[i].acInd == inP->acInd[index] && day == legInfosCP[i].day );

				if( legInfosCP[i].acInd != legInfosCP[i+1].acInd )
				{
					_ASSERTE( inP->acEndLeg[index]  == i );
					index ++;
				}
			}
			_ASSERTE( inP->acInd[index] >= 0 && legInfosCP[i].acInd == inP->acInd[index] && inP->numAc == index+1 && inP->acEndLeg[index] == i ) ;

			//start time fixed 
			tempTm = inP->firstLegP->leg->schedOut ;
			if( inP->tmFixed == DL_StartTmFixed || inP->tmFixed == DL_BothTmFixed )
				_ASSERTE ( inP->firstLegP->noAcTurn[0] || acList[inP->acInd[0]].availDT >= tempTm || tempTm <= optParam.windowStart || inP->firstLegP->noPilotRest[0][0] 
				|| inP->firstLegP->noPilotRest[1][0] 
				|| crewList[pilotInd[0]].availDT + Minute*( crewList[pilotInd[0]].activityCode == 2 ? optParam.firstPreFltTm : optParam.preFlightTm) >= tempTm 
				|| crewList[pilotInd[1]].availDT + Minute*( crewList[pilotInd[1]].activityCode == 2 ? optParam.firstPreFltTm : optParam.preFlightTm) >= tempTm 
				|| (inP->firstLegP->prevAcLeg != NULL && inP->firstLegP->leg->crewPairInd != inP->firstLegP->prevAcLeg->leg->crewPairInd)
				|| (inP->firstLegP->prevPilotLegs[0] != NULL && inP->firstLegP->leg->crewPairInd != inP->firstLegP->prevPilotLegs[0]->leg->crewPairInd)
				|| (inP->firstLegP->prevPilotLegs[1] != NULL && inP->firstLegP->leg->crewPairInd != inP->firstLegP->prevPilotLegs[1]->leg->crewPairInd)
				|| (inP->firstLegP->prevPilotLegs[0] != NULL && inP->firstLegP->leg->schedOut < inP->firstLegP->prevPilotLegs[0]->leg->schedIn + longRestTm + 2*DiscrtLPInterval )
				|| (inP->firstLegP->prevPilotLegs[1] != NULL && inP->firstLegP->leg->schedOut < inP->firstLegP->prevPilotLegs[1]->leg->schedIn + longRestTm + 2*DiscrtLPInterval ));

			if( inP->firstLegP->noAcTurn[0] || acList[inP->acInd[0]].availDT >= tempTm || tempTm <= optParam.windowStart || inP->firstLegP->noPilotRest[0][0] 
			|| inP->firstLegP->noPilotRest[1][0] || crewList[pilotInd[0]].availDT >= tempTm || crewList[pilotInd[1]].availDT >= tempTm )
				_ASSERTE( inP->tmFixed == DL_DutyCombined || inP->tmFixed == DL_StartTmFixed || inP->tmFixed == DL_BothTmFixed );

			//end time fixed
			tempTm = inP->lastLegP->leg->schedIn ;
			if( inP->tmFixed == DL_EndTmFixed || inP->tmFixed == DL_BothTmFixed )
				_ASSERTE( inP->lastLegP->noAcTurn[1] || inP->lastLegP->noPilotRest[0][1] || inP->lastLegP->noPilotRest[1][1] 
				|| (inP->lastLegP->nextAcLeg != NULL && inP->lastLegP->leg->crewPairInd != inP->lastLegP->nextAcLeg->leg->crewPairInd)
				|| (inP->lastLegP->nextPilotLegs[0] != NULL && inP->lastLegP->leg->crewPairInd != inP->lastLegP->nextPilotLegs[0]->leg->crewPairInd)
				|| (inP->lastLegP->nextPilotLegs[1] != NULL && inP->lastLegP->leg->crewPairInd != inP->lastLegP->nextPilotLegs[1]->leg->crewPairInd)
				|| inP->lastLegP->leg->schedIn + Minute*optParam.turnTime >= optParam.windowEnd );

			if( inP->lastLegP->noAcTurn[1] && inP->lastLegP->noPilotRest[0][1] || inP->lastLegP->noPilotRest[1][1] )
				_ASSERTE( inP->tmFixed == DL_DutyCombined || inP->tmFixed == DL_EndTmFixed || inP->tmFixed == DL_BothTmFixed );

			dutyNum ++ ;
		}//end for( day=0; day < optParam.planningWindowDuration; day ++ )
	}//end for (cpInd=0; cpInd< numCrewPairs; cpInd++)

	//go through  legs to check days
	for( i = 0; i < numPropMgdLegs; i ++)
	{
		const DL_LegInfo *inP = &(legInfosCP[i]) ;
		_ASSERTE( inP->day >= 0 ) ;

		iPilotInd[0] = crewPairList[inP->leg->crewPairInd].crewListInd[0];
		iPilotInd[1] = crewPairList[inP->leg->crewPairInd].crewListInd[1];

		if( i < numPropMgdLegs - 1 && legInfosCP[i].leg->crewPairInd == legInfosCP[i+1].leg->crewPairInd )
			_ASSERTE( legInfosCP[i].day <= legInfosCP[i+1].day ) ;

		for( j = 0; j < numPropMgdLegs; j ++)//compare all other legs to legInfosCP[i]
		{
			if( j == i )
				continue;

			jPilotInd[0] = crewPairList[legInfosCP[j].leg->crewPairInd].crewListInd[0];
			jPilotInd[1] = crewPairList[legInfosCP[j].leg->crewPairInd].crewListInd[1];

			if( legInfosCP[j].acInd == inP->acInd )//same ac as i
			{
				if(  legInfosCP[j].leg->schedIn <= inP->leg->schedOut ) //j before i 
					_ASSERTE( legInfosCP[j].day <= inP->day );
				else
					_ASSERTE( legInfosCP[j].day >= inP->day );
			}

			for(m=0; m<2; m++) //check pilot m
				if( jPilotInd[0] == iPilotInd[m] || jPilotInd[1] == iPilotInd[m] )
				{
					if( legInfosCP[j].leg->schedIn <= inP->leg->schedOut )//j before i 
						_ASSERTE( legInfosCP[j].day <= inP->day );
					else
						_ASSERTE( legInfosCP[j].day >= inP->day) ;
				}
		}//end for( j = 0; j < numPropMgdLegs; j ++)

		//other direction
		_ASSERTE( (inP->prevAcLeg == NULL || inP->prevAcLeg->day <= inP->day)
		&& ( inP->nextAcLeg == NULL || inP->nextAcLeg->day >= inP->day ) 
		&& ( inP->prevPilotLegs[0] == NULL || inP->prevPilotLegs[0]->day <= inP->day )
		&& ( inP->prevPilotLegs[1] == NULL || inP->prevPilotLegs[1]->day <= inP->day )
		&& ( inP->nextPilotLegs[0] == NULL || inP->nextPilotLegs[0]->day >= inP->day )
		&& ( inP->nextPilotLegs[1] == NULL || inP->nextPilotLegs[1]->day >= inP->day )) ;
	}//end for( i = 0; i < numPropMgdLegs; i ++)

	return 0 ;
}

static int checkLegsCP( const DL_LegInfo *legInfosCP )
{
	int i, j, m, k, iPilotInd[2], jPilotInd[2] ;
	const time_t longRestTm =  Minute*(optParam.minRestTm + optParam.postFlightTm + optParam.preFlightTm) ;

	_ASSERTE( legInfosCP != NULL ) ;
	//consider legInfosCP[i]
	for( i = 0; i < numPropMgdLegs; i ++)
	{
		const DL_LegInfo *inP = &(legInfosCP[i]) ;

		iPilotInd[0] = crewPairList[inP->leg->crewPairInd].crewListInd[0];
		iPilotInd[1] = crewPairList[inP->leg->crewPairInd].crewListInd[1];
		
		_ASSERTE( inP->leg != NULL && inP->legInd >= 0 && inP->leg == &(propMgdLegs[inP->legInd]) && inP->legIndCP == i
		&& inP->acInd == acIDToInd(inP->leg->aircraftID) && inP->schOutDay == timeToDay(inP->leg->schedOut)
		&& inP->schInDay == timeToDay(inP->leg->schedIn) );

		for( j = 0; j < numPropMgdLegs; j ++)//compare all other legs to legInfosCP[i]
		{
			if( j == i )
				continue;

			jPilotInd[0] = crewPairList[legInfosCP[j].leg->crewPairInd].crewListInd[0];
			jPilotInd[1] = crewPairList[legInfosCP[j].leg->crewPairInd].crewListInd[1];

			if( legInfosCP[j].acInd == inP->acInd )//same ac as i
			{
				if(  legInfosCP[j].leg->schedIn <= inP->leg->schedOut ) //j before i 
					_ASSERTE( inP->prevAcLeg != NULL && legInfosCP[j].leg->schedIn <= inP->prevAcLeg->leg->schedIn
					&& legInfosCP[j].nextAcLeg != NULL && legInfosCP[j].nextAcLeg->leg->schedOut <= inP->leg->schedOut );
				else
					_ASSERTE( inP->nextAcLeg != NULL && legInfosCP[j].leg->schedOut >= inP->leg->schedIn
					&& legInfosCP[j].leg->schedOut >= inP->nextAcLeg->leg->schedOut 
					&& legInfosCP[j].prevAcLeg != NULL && legInfosCP[j].prevAcLeg->leg->schedOut >= inP->leg->schedOut );
			}

			for(m=0; m<2; m++) //check pilot m
				if( jPilotInd[0] == iPilotInd[m] || jPilotInd[1] == iPilotInd[m] )
				{
					k = ( jPilotInd[0] == iPilotInd[m] ? 0 : 1 ) ; //pilot index in leg j

					if( legInfosCP[j].leg->schedIn <= inP->leg->schedOut )//j before i 
						_ASSERTE( inP->prevPilotLegs[m] != NULL && legInfosCP[j].leg->schedIn <= inP->prevPilotLegs[m]->leg->schedIn
						&& legInfosCP[j].nextPilotLegs[k] != NULL && legInfosCP[j].nextPilotLegs[k]->leg->schedOut <= inP->leg->schedOut );
					else
						_ASSERTE( legInfosCP[j].leg->schedOut >= inP->leg->schedIn && inP->nextPilotLegs[m] != NULL
						&& legInfosCP[j].leg->schedOut >= inP->nextPilotLegs[m]->leg->schedOut 
						&& legInfosCP[j].prevPilotLegs[k] != NULL && legInfosCP[j].prevPilotLegs[k]->leg->schedOut >= inP->leg->schedOut ) ;
				}
		}//end for( j = 0; j < numPropMgdLegs; j ++)

		//other direction
		if( inP->prevAcLeg != NULL )
		{
			_ASSERTE( inP->prevAcLeg->acInd == inP->acInd && inP->prevAcLeg->leg->schedIn <= inP->leg->schedOut && inP->prevAcLeg->nextAcLeg == inP ) ;

			if( inP->noAcTurn[0] )
				_ASSERTE( inP->prevAcLeg->noAcTurn[1] && inP->prevAcLeg->leg->schedIn + Minute*optParam.turnTime > inP->leg->schedOut ) ;
			else
				_ASSERTE( !inP->prevAcLeg->noAcTurn[1] && inP->prevAcLeg->leg->schedIn + Minute*optParam.turnTime <= inP->leg->schedOut ) ;
		} else
			_ASSERTE( !inP->noAcTurn[0] );

		if( inP->nextAcLeg != NULL )
		{
			_ASSERTE( inP->nextAcLeg->acInd == inP->acInd && inP->nextAcLeg->leg->schedOut >= inP->leg->schedIn && inP->nextAcLeg->prevAcLeg == inP ) ;

			if( inP->noAcTurn[1] )
				_ASSERTE( inP->nextAcLeg->noAcTurn[0] && inP->leg->schedIn + Minute*optParam.turnTime > inP->nextAcLeg->leg->schedOut ) ;
			else
				_ASSERTE( !inP->nextAcLeg->noAcTurn[0] && inP->leg->schedIn + Minute*optParam.turnTime <= inP->nextAcLeg->leg->schedOut ) ;
		} else
			_ASSERTE( !inP->noAcTurn[1] );

		for(m=0; m<2; m++)//for each pilot
		{
			if( inP->prevPilotLegs[m] != NULL )
			{
				j = inP->prevPilotLegs[m]->leg->crewPairInd ; //crew pair index of the prev pilot leg
				if( crewPairList[j].crewListInd[0] == iPilotInd[m] )//update to be the index of this pilot
					j = 0 ;
				else
				{
					_ASSERTE( crewPairList[j].crewListInd[1] == iPilotInd[m] );
					j = 1;
				}

				_ASSERTE( inP->prevPilotLegs[m]->leg->schedIn <= inP->leg->schedOut && inP->prevPilotLegs[m]->nextPilotLegs[j] == inP) ;

				if( inP->noPilotRest[m][0] )
					_ASSERTE( inP->prevPilotLegs[m]->noPilotRest[j][1] && inP->prevPilotLegs[m]->leg->schedIn + longRestTm > inP->leg->schedOut ) ;
				else
					_ASSERTE( !inP->prevPilotLegs[m]->noPilotRest[j][1] && inP->prevPilotLegs[m]->leg->schedIn + longRestTm <= inP->leg->schedOut ) ;

			} else
				_ASSERTE( !inP->noPilotRest[m][0] );
			//end if( inP->prevPilotLegs[m] != NULL )

			if( inP->nextPilotLegs[m] != NULL)
			{
				j = inP->nextPilotLegs[m]->leg->crewPairInd ;
				if( crewPairList[j].crewListInd[0] == iPilotInd[m]  )
					j = 0 ;
				else
				{
					_ASSERTE( crewPairList[j].crewListInd[1] == iPilotInd[m] );
					j = 1;
				}

				_ASSERTE( inP->nextPilotLegs[m]->leg->schedOut >= inP->leg->schedIn && inP->nextPilotLegs[m]->prevPilotLegs[j] == inP ) ;

				if( inP->noPilotRest[m][1] )
					_ASSERTE( inP->nextPilotLegs[m]->noPilotRest[j][0] && inP->leg->schedIn + longRestTm > inP->nextPilotLegs[m]->leg->schedOut ) ;
				else
					_ASSERTE( !inP->nextPilotLegs[m]->noPilotRest[j][0] && inP->leg->schedIn + longRestTm <= inP->nextPilotLegs[m]->leg->schedOut ) ;

			} else
				_ASSERTE( !inP->noPilotRest[m][1] );
			//end if( temP->nextPilotLegs[m] != NULL )

		}//end for(m=0; m<2; m++)
	}//end for( i = 0; i < numPropMgdLegs; i ++)

	return 0 ;
}


static int checkCpAcStartInfo( const DL_LegInfo *legInfosCP, const DL_CpAcAssign **cpAcAssigns, const DL_CpAcStartInfo *cpAcStartInfos, 
const int numStartInfo, const DL_AvailInfo *availAcs, const DL_AvailInfo *availPilots )
{
	int i, j ;

	_ASSERTE( cpAcStartInfos != NULL && numStartInfo > 0 ) ;
	for (j=0; j< numStartInfo; j++)
	{	
		const DL_CpAcStartInfo *inP = &(cpAcStartInfos[j]) ;

		_ASSERTE( inP->acAvail.ind >= 0 && inP->cpInd >= 0 
		&& ( crewPairList[inP->cpInd].acTypeIndex == acList[inP->acAvail.ind].acTypeIndex || inP->type == DL_FromExist )
		&& inP->pilotAvail[0].ind == crewPairList[inP->cpInd].crewListInd[0] && inP->pilotAvail[1].ind == crewPairList[inP->cpInd].crewListInd[1]
		&& inP->acCpDay >= 0 && inP->legStartDay >= inP->acCpDay && inP->legEndDay >= inP->legStartDay && inP->lastPossibleDay >= inP->legEndDay 
		&& optParam.planningWindowDuration >= inP->lastPossibleDay 
		&& ( inP->firstLegStart == 0 
		|| cpAcAssigns[inP->cpInd][inP->legStartDay].tmFixed == DL_StartTmFixed || cpAcAssigns[inP->cpInd][inP->legStartDay].tmFixed == DL_BothTmFixed 
		|| cpAcAssigns[inP->cpInd][inP->legStartDay].tmFixed == DL_DutyCombined
		|| (inP->acAvail.tm <= inP->firstLegStart && inP->pilotAvail[0].tm - DayInSecs*crewList[inP->pilotAvail[0].ind].startEarly <= inP->firstLegStart 
		&& inP->pilotAvail[1].tm - DayInSecs*crewList[inP->pilotAvail[1].ind].startEarly <= inP->firstLegStart ))) ;

		for(i=0; i<2; i++)
		{
			if( inP->type != DL_NewAvail ) //opt tour
			{
				if( availPilots[inP->pilotAvail[i].ind].tm )//pilot available after this opt tour
					_ASSERTE( availPilots[inP->pilotAvail[i].ind].latestLegEndB4HTravel >= availPilots[inP->pilotAvail[i].ind].tm + Minute*optParam.preFlightTm + MinCrewInterval );
				else
					_ASSERTE( cpAcAssigns[inP->cpInd][inP->legEndDay].numAc //last duty of this opt tour
					&& availPilots[inP->pilotAvail[i].ind].latestLegEndB4HTravel >= cpAcAssigns[inP->cpInd][inP->legEndDay].lastLegP->leg->schedIn
					&& (availPilots[inP->pilotAvail[i].ind].latestLegEndB4HTravel <= crewList[inP->pilotAvail[i].ind].tourEndTm - Minute*optParam.postFlightTm
					|| availPilots[inP->pilotAvail[i].ind].latestLegEndB4HTravel == cpAcAssigns[inP->cpInd][inP->legEndDay].lastLegP->leg->schedIn ));
			} else //new tour
				_ASSERTE( availPilots[inP->pilotAvail[i].ind].latestLegEndB4HTravel >= inP->pilotAvail[i].tm + Minute*optParam.preFlightTm + MinCrewInterval 
				&& availPilots[inP->pilotAvail[i].ind].latestLegEndB4HTravel <= crewList[inP->pilotAvail[i].ind].tourEndTm - Minute*optParam.postFlightTm );
		}

		if( inP->type != DL_NewAvail )//from current optimal tours
		{
			_ASSERTE( cpAcAssigns[inP->cpInd] != NULL && cpAcAssigns[inP->cpInd][inP->legStartDay].numAc && cpAcAssigns[inP->cpInd][inP->legEndDay].numAc 
			&& inP->firstLegStart > 0 && cpAcAssigns[inP->cpInd][inP->legStartDay].firstLegP->leg->schedOut == inP->firstLegStart ) ;

			//check next pointer
			for (i=0; i< numStartInfo; i++)
				if( cpAcStartInfos[i].type != DL_NewAvail && cpAcStartInfos[i].firstLegStart > inP->firstLegStart )
				{
					if( cpAcStartInfos[i].acAvail.ind == inP->acAvail.ind )
						_ASSERTE( inP->acNext && inP->acNext->firstLegStart <= cpAcStartInfos[i].firstLegStart );

					if( cpAcStartInfos[i].pilotAvail[0].ind == inP->pilotAvail[0].ind || cpAcStartInfos[i].pilotAvail[1].ind == inP->pilotAvail[0].ind )
						_ASSERTE( inP->pilotNext[0] && inP->pilotNext[0]->firstLegStart <= cpAcStartInfos[i].firstLegStart );

					if( cpAcStartInfos[i].pilotAvail[0].ind == inP->pilotAvail[1].ind || cpAcStartInfos[i].pilotAvail[1].ind == inP->pilotAvail[1].ind )
						_ASSERTE( inP->pilotNext[1] && inP->pilotNext[1]->firstLegStart <= cpAcStartInfos[i].firstLegStart );
				}

			if( inP->acNext )
				_ASSERTE( inP->acNext->acAvail.ind == inP->acAvail.ind && inP->acNext->type != DL_NewAvail && inP->acNext->firstLegStart > inP->firstLegStart );
			
			for (i=0; i< 2; i++)
				if( inP->pilotNext[i] )
					_ASSERTE( (inP->pilotNext[i]->pilotAvail[0].ind == inP->pilotAvail[i].ind || inP->pilotNext[i]->pilotAvail[1].ind == inP->pilotAvail[i].ind )
					&& inP->acNext->type != DL_NewAvail && inP->pilotNext[i]->firstLegStart > inP->firstLegStart );
		} else//extra cp and ac
		{
			//for(i=inP->acCpDay; i <= inP->lastPossibleDay; i ++)
			//	_ASSERTE( cpAcAssigns[inP->cpInd] == NULL || !cpAcAssigns[inP->cpInd][i].numAc );
			_ASSERTE(inP->firstLegStart == 0 && !inP->acNext && !inP->pilotNext[0] && !inP->pilotNext[1] ) ;
		}//end

		for(i=0; i<2; i++)
		{
			_ASSERTE( inP->pilotAvail[i].apt > 0 && inP->pilotAvail[i].tm > 0 );
			if( inP->pilotAvail[i].status )
				_ASSERTE( inP->pilotAvail[i].dutyStartTm == 0 );
			else
				_ASSERTE( inP->pilotAvail[i].dutyStartTm > 0 && inP->pilotAvail[i].dutyStartTm <= inP->pilotAvail[i].tm );
		}//end for(i=0; i<2; i++)
	}//end for (j=0; j< numStartInfo; j++)

	for(j=0; j<numAircraft; j++)
	{
		_ASSERTE( availAcs[j].dutyStartTm == 0 && availAcs[j].status == 0 && availAcs[j].ind == j );
		if( availAcs[j].tm )
		{
			_ASSERTE( availAcs[j].apt && availAcs[j].availAfter && (availAcs[j].day == timeToDay(availAcs[j].tm) 
			|| availAcs[j].day == timeToDay(availAcs[j].tm) + 1));
		} else
		{
			_ASSERTE( !availAcs[j].apt && !availAcs[j].availAfter && availAcs[j].day == -1);
		}
	}

	for(j=0; j<numCrew; j++)
	{
		_ASSERTE( availPilots[j].ind == j );
		if( availPilots[j].tm )
		{
			_ASSERTE( availPilots[j].dutyStartTm <= availPilots[j].tm
			&& availPilots[j].apt && availPilots[j].availAfter && (availPilots[j].day == timeToDay(availPilots[j].tm) 
			|| availPilots[j].day == timeToDay(availPilots[j].tm) + 1));
		} else
		{
			_ASSERTE( !availPilots[j].dutyStartTm && !availPilots[j].apt && !availPilots[j].availAfter && availPilots[j].day == -1);
		}
	}

	return 0 ;
}

static int printManagedLegs(const DL_LegInfo *legInfosCP)
{
	int i ;	
	char opbuf1[1024], opbuf2[1024] ;

	fprintf (dlFile, "--> Managed legs:\n");
	fprintf (dlFile, "+------------+-----------+-------------+----------+----------+------------+------------+------------+------------+------------------+------------------+----+\n");
	fprintf (dlFile, "| Index      | Demand ID | Aircraft ID |  PIC ID  |  SIC ID  | Out Apt ID | Out FBO ID |  In Apt ID |  In FBO ID |     Out Time     |     In Time      | ex?|\n");
	fprintf (dlFile, "+------------+-----------+-------------+----------+----------+------------+------------+------------+------------+------------------+------------------+----+\n");
	for (i=0; i<numPropMgdLegs; i++)
	{
		fprintf (dlFile, "|   %6d   |  %6d   |   %6d    |  %6d  |  %6d  |   %6d   |   %6d   |   %6d   |   %6d   | %16s | %16s | %2d |\n",
			i, 
			legInfosCP[i].leg->demandID, 
			legInfosCP[i].leg->aircraftID,
			legInfosCP[i].leg->captainID,
			legInfosCP[i].leg->FOID,
			legInfosCP[i].leg->schedOutAptID,
			legInfosCP[i].leg->schedOutFBOID,
			legInfosCP[i].leg->schedInAptID,
			legInfosCP[i].leg->schedInFBOID,
			dt_DateTimeToDateTimeString(dt_time_tToDateTime (legInfosCP[i].leg->schedOut), opbuf1, "%Y/%m/%d %H:%M"),
			dt_DateTimeToDateTimeString(dt_time_tToDateTime (legInfosCP[i].leg->schedIn), opbuf2, "%Y/%m/%d %H:%M"),
			legInfosCP[i].leg->exgTour
		);
		
		if ( i < numPropMgdLegs-1 && legInfosCP[i].acInd != legInfosCP[i+1].acInd )
			fprintf (dlFile, "+------------+-----------+-------------+----------+----------+------------+------------+------------+------------+------------------+------------------+----+\n");
	}
	fprintf (dlFile, "+------------+-----------+-------------+----------+----------+------------+------------+------------+------------+------------------+------------------+----+\n");
	return 0 ;
}

static int cpIntersect( const int fInd, const int sInd, int *pIndF, int *pIndS )
{
	if( crewPairList[fInd].captainID == crewPairList[sInd].captainID )
	{
		if( pIndF != NULL )
			*pIndF = 0 ;
		if( pIndS != NULL )
			*pIndS = 0 ;
		return 1;
	}

	if( crewPairList[fInd].captainID == crewPairList[sInd].flightOffID )
	{
		if( pIndF != NULL )
			*pIndF = 0 ;
		if( pIndS != NULL )
			*pIndS = 1 ;
		return 1;
	}

	if( crewPairList[fInd].flightOffID == crewPairList[sInd].captainID )
	{
		if( pIndF != NULL )
			*pIndF = 1 ;
		if( pIndS != NULL )
			*pIndS = 0 ;
		return 1;
	}

	if( crewPairList[fInd].flightOffID == crewPairList[sInd].flightOffID )
	{
		if( pIndF != NULL )
			*pIndF = 1 ;
		if( pIndS != NULL )
			*pIndS = 1 ;
		return 1;
	}
	return 0 ;
}

//get assignments of current cp and ac on dayOne
static int generateAnAssignment(const DL_AvailInfo *availPilots, const DL_CpAcAssign **cpAcAssigns, const DL_CpAcStartInfo *startP, const int dayZero
, const int dayOne, DL_Column **assignmentsP, int *numAssignmentsP)
{
	time_t departTm, dutyStartTm, arrivalTm, preFltTm, pAvailTm[2], availTmB4Duty ; 
	double cost; 
	int i, j, numTmpData ;
	DL_Column *aP = NULL ;
	//const DL_CpAcStartInfo *startP = &(cpAcStartInfos[index]) ;
	const DL_CpAcAssign *curCpAcP = NULL, *prevCpAcP = NULL, *nextCpAcP = NULL ;
	DL_LegInfo *legP = NULL ;
	DL_DataOneDay tmpData[DL_MAX_NUM_ALT_AC_PER_DUTY], *curDataP = NULL;
	time_t adjRestTm ;
	
	const time_t longRestTm = Minute*(optParam.minRestTm + optParam.postFlightTm + optParam.preFlightTm) ;
	const time_t longRestFirstTm = Minute*(optParam.minRestTm + optParam.postFlightTm + optParam.firstPreFltTm) ;
	const time_t shortDutyTm =  Minute*(optParam.maxDutyTm - optParam.preFlightTm - optParam.postFlightTm) ;//used for elimination, feasible

	memset(&tmpData, 0, sizeof(DL_DataOneDay) );//initialize, array of data entries
	memset(pAvailTm, 0, sizeof(pAvailTm) );//pilot available time including pre flight time
	availTmB4Duty = 0 ; //resource available time before current duty
	
	numTmpData = 1; //number of data entries //initialize
	curDataP = &(tmpData[numTmpData-1]);//temp hold current data

/////////////////////////////////////////////////////////////////////////get the time interval for current cp on dayOne
	if( cpAcAssigns[startP->cpInd] != NULL ) //cp is assigned in the opt solution
	{
		//consider this cp's assignment on dayOne
		curCpAcP = &(cpAcAssigns[startP->cpInd][dayOne]) ;

		//duty before current day
		for( i = dayOne-1; i >= 0; i --)
			 if( cpAcAssigns[startP->cpInd][i].numAc )
			 {
				 prevCpAcP = &(cpAcAssigns[startP->cpInd][i]) ;
				 break;
			 }

		//duty after current day
		for( i = dayOne+1; i < optParam.planningWindowDuration; i ++)
			if( cpAcAssigns[startP->cpInd][i].numAc )
			{
				nextCpAcP = &(cpAcAssigns[startP->cpInd][i]) ;
				break ;
			}
		_ASSERTE( !nextCpAcP || startP->type != DL_NewAvail ) ;

///////////////////////////////////////////////////////////////////////////////////////////////////set pilot available info before current duty
		if( prevCpAcP )//there is prev duty for this cp
		{
			curDataP->pAirports[1] = curDataP->pAirports[0] =  prevCpAcP->lastLegP->leg->schedInAptID ;
			curDataP->pTm[1] = curDataP->pTm[0] = prevCpAcP->lastLegP->leg->schedIn + Minute*(optParam.postFlightTm + optParam.minRestTm) ;
			pAvailTm[1] = pAvailTm[0] = curDataP->pTm[0] + Minute*optParam.preFlightTm ;
		} else // first duty for this cp, use start info to set pilot's available time
		{
			for(j=0; j < 2 ; j++)
			{
				curDataP->pAirports[j] = startP->pilotAvail[j].apt ;
				curDataP->pTm[j] = startP->pilotAvail[j].tm ;
				pAvailTm[j] = curDataP->pTm[j] + Minute*( startP->pilotAvail[j].status == PilotRestB4FirstLeg ? optParam.firstPreFltTm : optParam.preFlightTm ) ;
			}
		}

		if( curCpAcP->numAc ) //cp is assigned on current day
		{
			_ASSERTE( startP->type != DL_NewAvail ) ;
///////////////////////////////////////////////////////////////////////////////////////////////////set ac available info before current duty
			curDataP->acInd = curCpAcP->acInd[0] ; //take first ac
			if( (legP = curCpAcP->firstLegP->prevAcLeg) != NULL )//there is prev ac leg
			{
				curDataP->acAirport = legP->leg->schedInAptID ;
				curDataP->acTm = legP->leg->schedIn + Minute*optParam.turnTime ;
			} else//no prev ac leg
			{
				_ASSERTE( ( !prevCpAcP || prevCpAcP->acInd[prevCpAcP->numAc-1] != curCpAcP->acInd[0] )
				//&& acList[curCpAcP->acInd[0]].availDT <= curCpAcP->firstLegP->leg->schedOut 
				&& acList[curCpAcP->acInd[0]].availAirportID == curCpAcP->firstLegP->leg->schedOutAptID );

				curDataP->acAirport = acList[curCpAcP->acInd[0]].availAirportID ;
				curDataP->acTm = acList[curCpAcP->acInd[0]].availDT;
			}

			//resource available time
			availTmB4Duty = max( curDataP->acTm, max(pAvailTm[0], pAvailTm[1])) ;

///////////////////////////////////////////////////////////////////////////////////////////////////set the interval
			if( curCpAcP->tmFixed == DL_BothTmFixed || curCpAcP->tmFixed == DL_DutyCombined ) //time fixed (if there are two cp's of one pilot)
			{
				curDataP->lStartTm = curDataP->eStartTm = curCpAcP->firstLegP->leg->schedOut ;
				curDataP->lEndTm = curDataP->eEndTm = curCpAcP->lastLegP->leg->schedIn ;
				curDataP->keepOriginal = ( curCpAcP->tmFixed == DL_BothTmFixed ? DL_KO_TmFixed : DL_KO_Combined );
			} else
			{
///////////////////////////////////////////////////////////////////////////////////////////////////consider start time
				curDataP->lStartTm = curCpAcP->firstLegP->leg->schedOut ;

				if( curCpAcP->tmFixed != DL_StartTmFixed )
				{
					_ASSERTE( availTmB4Duty <= curDataP->lStartTm ); 

					//start time: initialize to be day start time
					curDataP->eStartTm = (curCpAcP->firstLegP->schOutDay == 0 ? optParam.windowStart : firstEndOfDay + (curCpAcP->firstLegP->schOutDay  - 1)*DayInSecs ) ;
					
					//start time: compare to resource available time
					curDataP->eStartTm = max(curDataP->eStartTm, availTmB4Duty) ;

					//start time: compare to tour start time //not extending when overtime, unless pilot has prev duty
					for(j=0; j < 2; j ++)
						if( curCpAcP->firstLegP->prevPilotLegs[j] == NULL 
						&& crewList[startP->pilotAvail[j].ind].tourStartTm + Minute*optParam.firstPreFltTm > curDataP->eStartTm )
							curDataP->eStartTm = min(crewList[startP->pilotAvail[j].ind].tourStartTm + Minute*optParam.firstPreFltTm, curDataP->lStartTm) ;
					
					_ASSERTE( curDataP->lStartTm >= curDataP->eStartTm ) ;

					//interval too small, fix
					if( curDataP->lStartTm - curDataP->eStartTm < DiscrtCrewInterval )
						curDataP->eStartTm = curDataP->lStartTm ;//use lStartTm
				} else
					curDataP->eStartTm = curDataP->lStartTm ;

///////////////////////////////////////////////////////////////////////////////////////////////////consider end time
				curDataP->eEndTm = curCpAcP->lastLegP->leg->schedIn ;

				if( curCpAcP->tmFixed != DL_EndTmFixed )
				{
					//end time: initialize to be day end time
					curDataP->lEndTm = ( curCpAcP->lastLegP->schInDay == (optParam.planningWindowDuration - 1) ? optParam.windowEnd : firstEndOfDay + curCpAcP->lastLegP->schInDay*DayInSecs );

					//end time: compare to the leg with the same ac after current duty, check against end time
					if( (legP = curCpAcP->lastLegP->nextAcLeg ) != NULL && legP->leg->schedOut - Minute*optParam.turnTime < curDataP->lEndTm )
						curDataP->lEndTm = legP->leg->schedOut - Minute*optParam.turnTime ;

					//end time: compare to the leg with the same pilot after current duty, and tour end time
					for(j=0; j < 2; j ++)
					{
						if( (legP = curCpAcP->lastLegP->nextPilotLegs[j] ) != NULL )
						{
							if( legP->leg->schedOut - longRestTm <  curDataP->lEndTm )
								curDataP->lEndTm = legP->leg->schedOut - longRestTm ;
						} else if( availPilots[startP->pilotAvail[j].ind].latestLegEndB4HTravel < curDataP->lEndTm )//not extending when overtime, unless pilot has next duty
							curDataP->lEndTm = max(availPilots[startP->pilotAvail[j].ind].latestLegEndB4HTravel, curDataP->eEndTm) ;
					}
					_ASSERTE( curDataP->eEndTm <= curDataP->lEndTm ) ;

					//interval too small, fix
					if( curDataP->lEndTm - curDataP->eEndTm < DiscrtCrewInterval )
						 curDataP->lEndTm = curDataP->eEndTm;//use early end time
				} else
					curDataP->lEndTm = curDataP->eEndTm ;
			}//end else
		} else //current day not assigned, but is assigned on other days 
		{
			//start time: initialize early start time to be day start time
			curDataP->eStartTm = ( dayOne == 0 ? optParam.windowStart: (firstEndOfDay + (dayOne - 1)*DayInSecs) ) ;

			//end time: initialize late end time to be day end time
			curDataP->lEndTm = (dayOne == (optParam.planningWindowDuration - 1) ? optParam.windowEnd: (firstEndOfDay + dayOne*DayInSecs) ) ;

			_ASSERTE( prevCpAcP || nextCpAcP ); //exist either prev or next

			//special case: both prev and next duties exist AND have different airplanes --> generate two cases: one for each airplane
			if( prevCpAcP && nextCpAcP )
			{
				_ASSERTE( startP->type != DL_NewAvail );
///////////////////////first sub-case: crew the ac of the prev duty --> check the next leg of this ac --> current duty must end before it
				curDataP->acInd = prevCpAcP->acInd[prevCpAcP->numAc -1] ;
				curDataP->acAirport = prevCpAcP->lastLegP->leg->schedInAptID ;
				curDataP->acTm = prevCpAcP->lastLegP->leg->schedIn + Minute*optParam.turnTime ;
				
				//start time: compare to resource available time
				availTmB4Duty = max( curDataP->acTm, max(pAvailTm[0], pAvailTm[1])) ;
				//no need to compare to tour start time
				curDataP->eStartTm = max( curDataP->eStartTm, availTmB4Duty);

				//end time: compare to next ac leg
				if( (legP = prevCpAcP->lastLegP->nextAcLeg) != NULL && legP->leg->schedOut - Minute*optParam.turnTime < curDataP->lEndTm )
					curDataP->lEndTm = legP->leg->schedOut - Minute*optParam.turnTime ;
				
				//end time: next pilot time; same for both pilots
				if( nextCpAcP->firstLegP->leg->schedOut - longRestTm < curDataP->lEndTm )
					curDataP->lEndTm = nextCpAcP->firstLegP->leg->schedOut - longRestTm ;

				//no need to compare to tour end time

///////////////////////second case: crew the ac of the next duty --> check the prev leg of this ac --> current duty must start after it
				if( prevCpAcP->acInd[prevCpAcP->numAc -1] != nextCpAcP->acInd[0]  )
				{
					memmove((curDataP = &(tmpData[numTmpData]) ), &(tmpData[numTmpData-1]), sizeof(DL_DataOneDay));//copy existing info
					
					curDataP->acInd = nextCpAcP->acInd[0] ;
					if( (legP = nextCpAcP->firstLegP->prevAcLeg) != NULL )
					{
						curDataP->acAirport = legP->leg->schedInAptID ;
						curDataP->acTm = legP->leg->schedIn + Minute*optParam.turnTime ;
					} else//no prev ac leg
					{
						_ASSERTE( //acList[nextCpAcP->acInd[0]].availDT <= nextCpAcP->firstLegP->leg->schedOut 
						acList[nextCpAcP->acInd[0]].availAirportID == nextCpAcP->firstLegP->leg->schedOutAptID );

						curDataP->acAirport = acList[curCpAcP->acInd[0]].availAirportID ;
						curDataP->acTm = acList[curCpAcP->acInd[0]].availDT ;
					}
					//start time: compare to resource available time
					availTmB4Duty = max( curDataP->acTm, max(pAvailTm[0], pAvailTm[1])) ;
					//start time: no need to compare to tour start time
					curDataP->eStartTm = max( curDataP->eStartTm, availTmB4Duty);

					//end time: no need to compare to tour end time
					//end time: next pilot times have been compared as above in tmpData[numTmpData-1], also implying the next ac time

					numTmpData ++;
					_ASSERTE( numTmpData <= DL_MAX_NUM_ALT_AC_PER_DUTY );
				}//end if

			} else if( prevCpAcP && !nextCpAcP )//prev, no next: crew the last ac of the prev duty
			{
				//two cases depending on startP : opt tour containing prevCpAcP, or a new tour with same crew pair
				if( startP->type != DL_NewAvail )//include prevCpAcP
				{
					curDataP->acInd = prevCpAcP->acInd[prevCpAcP->numAc -1] ;
					curDataP->acAirport = prevCpAcP->lastLegP->leg->schedInAptID ;
					curDataP->acTm = prevCpAcP->lastLegP->leg->schedIn + Minute*optParam.turnTime ;
				} else//different from prevCpAcP
				{
					_ASSERTE( startP->acAvail.ind != prevCpAcP->acInd[prevCpAcP->numAc -1] ); 
					curDataP->acInd = startP->acAvail.ind ;
					curDataP->acAirport = startP->acAvail.apt ;
					curDataP->acTm = startP->acAvail.tm ;
				}

				//start time: compare to resource available time
				availTmB4Duty = max( curDataP->acTm, max(pAvailTm[0], pAvailTm[1])) ;
				//start time: no need to compare to tour start time
				curDataP->eStartTm = max( curDataP->eStartTm, availTmB4Duty);

				//end time: compare to the next leg of the same ac, for opt tours
				if( startP->type != DL_NewAvail && (legP = prevCpAcP->lastLegP->nextAcLeg) != NULL && legP->leg->schedOut - Minute*optParam.turnTime < curDataP->lEndTm )
					curDataP->lEndTm = legP->leg->schedOut - Minute*optParam.turnTime ;

				//end time: compare to the next leg of the same pilot, or tour end time
				for(j=0; j < 2; j ++)
					if( (legP = prevCpAcP->lastLegP->nextPilotLegs[j] ) != NULL )
					{
						if( legP->leg->schedOut - longRestTm <  curDataP->lEndTm )
							curDataP->lEndTm = legP->leg->schedOut - longRestTm ;
					} else if( availPilots[startP->pilotAvail[j].ind].latestLegEndB4HTravel < curDataP->lEndTm )//not  extending when overtime, unless pilot has next duty
						curDataP->lEndTm = availPilots[startP->pilotAvail[j].ind].latestLegEndB4HTravel ;

			} else if( !prevCpAcP && nextCpAcP )//next, no prev: crew the first ac of the next duty: use start info
			{
				_ASSERTE( startP->type != DL_NewAvail && startP->acAvail.ind == nextCpAcP->acInd[0] );

				curDataP->acInd = nextCpAcP->acInd[0] ;
				curDataP->acAirport = startP->acAvail.apt ;
				curDataP->acTm = startP->acAvail.tm ;

				//start time: compare to resource available time
				availTmB4Duty = max( curDataP->acTm, max(pAvailTm[0], pAvailTm[1])) ;
				curDataP->eStartTm = max( curDataP->eStartTm, availTmB4Duty);

				//start time: compare tour start time
				for(j=0; j < 2; j ++)
					if( (legP = nextCpAcP->firstLegP->prevPilotLegs[j] ) == NULL )
						curDataP->eStartTm = max( curDataP->eStartTm, crewList[startP->pilotAvail[j].ind].tourStartTm + Minute*optParam.firstPreFltTm );

				//end time: next pilot time; same for both pilots; also implying next ac leg
				//check captain
				for(j=0; j < 2; j ++)
				{
					adjRestTm = ( startP->pilotAvail[j].status == PilotRestB4FirstLeg ? longRestFirstTm : longRestTm );
					curDataP->lEndTm = min(curDataP->lEndTm, nextCpAcP->firstLegP->leg->schedOut - adjRestTm) ;
				}

				//end time: no need to compare tour end time
			}
		}//end else
	} else //this cp not assigned
	{
		_ASSERTE( startP->type == DL_NewAvail && !startP->acNext && !startP->pilotNext[0] && !startP->pilotNext[1] );

		for(j=0; j < 2 ; j++)
		{
			curDataP->pAirports[j] = startP->pilotAvail[j].apt ;
			curDataP->pTm[j] = startP->pilotAvail[j].tm ;
			pAvailTm[j] = curDataP->pTm[j] + Minute*( startP->pilotAvail[j].status == PilotRestB4FirstLeg ? optParam.firstPreFltTm : optParam.preFlightTm ) ;
		}
		curDataP->acInd = startP->acAvail.ind ;
		curDataP->acAirport = startP->acAvail.apt ;
		curDataP->acTm = startP->acAvail.tm ;
		
		//compare to resource available time
		availTmB4Duty = max( curDataP->acTm, max(pAvailTm[0], pAvailTm[1])) ;

		//start time: initialize
		curDataP->eStartTm = ( dayOne == 0 ? optParam.windowStart: (firstEndOfDay + (dayOne - 1)*DayInSecs) ) ;
		//start time: compare to resource available time
		curDataP->eStartTm = max( curDataP->eStartTm, availTmB4Duty);
		//start time: compare tour start time
		for(j=0; j < 2; j ++)
			curDataP->eStartTm = max( curDataP->eStartTm, crewList[startP->pilotAvail[j].ind].tourStartTm + Minute*optParam.firstPreFltTm );

		//end time: initialize
		curDataP->lEndTm = (dayOne == (optParam.planningWindowDuration - 1) ? optParam.windowEnd : (firstEndOfDay + dayOne*DayInSecs) ) ;
		//end time: no need to check later legs of the same ac or pilot, if startP->type == DL_NewAvail
		//end time: tour end time
		for(j=0; j < 2; j ++) //no legs after
			curDataP->lEndTm = min( curDataP->lEndTm, availPilots[startP->pilotAvail[j].ind].latestLegEndB4HTravel );
	}//end else

/////////////////////////////////////////////////////////////////adjust interval
	if( curCpAcP && curCpAcP->numAc )//cp is assigned on current day
	{
		_ASSERTE( numTmpData == 1 );
		if( tmpData[0].eEndTm - tmpData[0].lStartTm > shortDutyTm)//if orginal duty violates, keep the original
		{
			tmpData[0].eStartTm = tmpData[0].lStartTm ;
			tmpData[0].lEndTm = tmpData[0].eEndTm ;
			tmpData[0].keepOriginal = DL_KO_DutyTime ;
		} else
		{
			//compare interval against max duty time
			tmpData[0].lEndTm = min(tmpData[0].lEndTm, tmpData[0].lStartTm + shortDutyTm ) ; //if max interval is too long, consider max duty time
			tmpData[0].eStartTm = max(tmpData[0].eStartTm, tmpData[0].eEndTm - shortDutyTm ) ;//if max interval is too long, consider max duty time

			_ASSERTE( tmpData[0].eStartTm <= tmpData[0].lStartTm && tmpData[0].eEndTm <= tmpData[0].lEndTm );

			if( tmpData[0].lStartTm - tmpData[0].eStartTm < DiscrtCrewInterval ) //interval may have been changed as above
				tmpData[0].eStartTm = tmpData[0].lStartTm ; //fix start time: use late start time

			if( tmpData[0].lEndTm - tmpData[0].eEndTm < DiscrtCrewInterval ) //interval may have been changed
				tmpData[0].lEndTm = tmpData[0].eEndTm ;//fix end time
		}
	} else//cp is not assigned: early start time and late end time are generated above
	{
		_ASSERTE( numTmpData >= 1 );
		j = 0; //whether feasible
		for(i=0; i < numTmpData; i++)
		{
			if( tmpData[i].lEndTm - tmpData[i].eStartTm < MinCrewInterval ) //including tmpData[i].lEndTm < tmpData[i].eStartTm
				continue ;
			
			j = 1; //feasible
			tmpData[i].lStartTm = tmpData[i].lEndTm - MinCrewInterval ; //set late start time
			//set early end time
			if( tmpData[i].lStartTm - tmpData[i].eStartTm < DiscrtCrewInterval ) //interval may have been changed as above
			{
				tmpData[i].eStartTm = tmpData[i].lStartTm ; //fix start time to be late start time
				tmpData[i].eEndTm = tmpData[i].lEndTm ; //fix end time to be late end time
			} else
			{
				tmpData[i].eEndTm = tmpData[i].eStartTm + MinCrewInterval ; 
				_ASSERTE( tmpData[i].lEndTm - tmpData[i].eEndTm >= DiscrtCrewInterval ) ;
			}
		}//end for
		if( !j )
			return 1;
	}
/////////////////////////////////////////////////////////////////////////end get the time interval for current cp and ac on dayOne
	
/////////////////////////////////////////////////////////////////////////pre check travels
	_ASSERTE( dayZero != dayOne || numTmpData == 1 );
	if( dayZero == dayOne && !tmpData[0].keepOriginal )
		for( j=0; j < 2; j ++ )//for each pilot
		{
			_ASSERTE( tmpData[0].pAirports[j] > 0 && tmpData[0].pTm[j] > 0 && tmpData[0].acAirport > 0 );
			if( tmpData[0].pAirports[j] != tmpData[0].acAirport )
			{
				if( startP->pilotAvail[j].status == PilotInDuty )
					preFltTm = Minute*optParam.preFlightTm ;
				else if ( startP->pilotAvail[j].status == PilotRestB4Leg )
					preFltTm = Minute*optParam.preFlightTm ;
				else
					preFltTm = Minute*optParam.firstPreFltTm ;

				//early travel to tmpData[0].lStartTm
				if ( tmpData[0].pTm[j] < tmpData[0].lStartTm - preFltTm
				&& !getCrewTravelDataEarly(tmpData[0].pTm[j], tmpData[0].lStartTm - preFltTm, tmpData[0].pAirports[j], tmpData[0].acAirport, &departTm
				, &dutyStartTm, &arrivalTm, &cost, withOag) )
				{
					tmpData[0].eStartTm = max( tmpData[0].eStartTm, arrivalTm + preFltTm );
					if( tmpData[0].lStartTm - tmpData[0].eStartTm < DiscrtCrewInterval ) //interval may have been changed as above
						tmpData[0].eStartTm = tmpData[0].lStartTm ; //fix start time: use late start time
				}
				//else if ( startP->type != DL_NewAvail && cpAcAssigns[startP->cpInd] != NULL && cpAcAssigns[startP->cpInd][dayOne].numAc ) //currently assigned on current day
				else if( curCpAcP && curCpAcP->numAc )
				{
					tmpData[0].keepOriginal = DL_KO_NoTravel ; //travel not feasible, but keep it 
					tmpData[0].eStartTm = tmpData[0].lStartTm; //not adjusting 
					tmpData[0].lEndTm = tmpData[0].eEndTm;
					break; //keep original
				} else
					return 1; //infeasible for current day
			}
		}//end for
/////////////////////////////////////////////////////////////////////////end pre check travels

/////////////////////////////////////////////////////////////////////////set additional attributes
	for( i=0; i < numTmpData; i ++ )
	{
		tmpData[i].cpAcAssignP = ( (!curCpAcP || !curCpAcP->numAc) ? NULL : curCpAcP ) ; //not null --> legs assigned
		//aP->acInd = startP->acInd;
		//aP->cpInd = startP->cpInd;
		tmpData[i].firstDay = dayZero;
		tmpData[i].day = dayOne;
		tmpData[i].startInfoP = startP;
		_ASSERTE( tmpData[i].eStartTm <= tmpData[i].lStartTm && tmpData[i].eEndTm <= tmpData[i].lEndTm) ;
	}
/////////////////////////////////////////////////////////////////////////set additional attributes

	return (generateAnAssignmentA(tmpData, numTmpData, assignmentsP, numAssignmentsP));
}


//get assignments of current cp and ac on dayOne
static int generateAnAssignmentA(DL_DataOneDay* tmpDataP, const int numTmpData, DL_Column **assignmentsP, int *numAssignmentsP)
{
	time_t tZero, tOne, departTm, dutyStartTm, arrivalTm, pDutyStartTm[2][DL_MAX_NUM_TRAVEL_PER_PILOT], pilotStartTm[2][DL_MAX_NUM_TRAVEL_PER_PILOT] ; 
	double cost, tCosts[2][DL_MAX_NUM_TRAVEL_PER_PILOT];
	int i, m, n, noNewCol, firstDuty[2] ;
	int flightTm, blockTm, elapsedTm, numStops, tempTm;
	DL_Column *aP = NULL, temCol;
	//const DL_CpAcStartInfo *startP = &(cpAcStartInfos[index]) ;
	DL_DataOneDay* inP=NULL;
	time_t preFltTm[2] ;
	const time_t minDutyTm = Minute*(30 + optParam.postFlightTm) ;//for travel
	const int cont = 1 ; //for trivial

	noNewCol = 1 ;//whether new columns found, return 
	for(i=0; i < numTmpData; i ++)
	{
		inP = &(tmpDataP[i]); 

		//get pre flight time before current tour
		for(n=0; n < 2; n ++)//for each pilot
		{
			//whether first duty of a pilot tour
			if( inP->day == inP->firstDay && inP->startInfoP->pilotAvail[n].status == PilotRestB4FirstLeg )
				firstDuty[n] = 1; 
			else
				firstDuty[n] = 0 ;
			//pre flight time after travel or rest, and before the first duty //may need even if current duty is not the first duty
			if( inP->startInfoP->pilotAvail[n].status == PilotInDuty )
				preFltTm[n] = Minute*optParam.preFlightTm ;
			else if ( inP->startInfoP->pilotAvail[n].status == PilotRestB4FirstLeg )
				preFltTm[n] = Minute*optParam.firstPreFltTm ;
			else
				preFltTm[n] = Minute*optParam.preFlightTm ;
		}

////////////////////////////////////////////////////////////////////////////check interval [tZero, tOne]
		tZero = inP->eStartTm ; //left end starts with early start time
		while ( cont ) //temp
		{
			//keepOriginal == 1 if this duty contains legs and
			//both start time and end time are fixed, or current duty time violates, or no feasible travels to the first leg start time
			_ASSERTE( !inP->keepOriginal 
			|| (inP->startInfoP->type != DL_NewAvail && *numAssignmentsP == 0 && inP->eStartTm == inP->lStartTm && inP->eEndTm == inP->lEndTm )) ;
			
			memset( pDutyStartTm, 0, sizeof(pDutyStartTm) ) ; //pilot duty start time b4 tZero: to check total duty time //[pilot][#travel]
			memset( pilotStartTm, 0, sizeof(pilotStartTm) ) ; //pilot start time b4 tZero: to connect //[pilot][#travel]
			memset( tCosts, 0, sizeof(tCosts) ) ; //travel cost for each pilot //[pilot][#travel]

///////////////////////////////////////////////////////////////////////////check travels
			if( inP->day == inP->firstDay && !inP->keepOriginal )
			{
				for(n=0; n < 2; n ++)//for each pilot
				{
					if( inP->pAirports[n] == inP->acAirport )//if trivial travel
					{
						if(inP->startInfoP->pilotAvail[n].status )//was resting
						{
							pilotStartTm[n][0] = pDutyStartTm[n][0] = tZero - preFltTm[n] ;//note: pre flight time
						} else if (inP->pTm[n] + Minute*(optParam.minRestTm + optParam.preFlightTm) <= tZero ) //can rest: two options
						{
							pilotStartTm[n][0] = pDutyStartTm[n][0] = tZero - Minute*optParam.preFlightTm ;//option: rest
							pilotStartTm[n][1] = pDutyStartTm[n][1] = inP->startInfoP->pilotAvail[n].dutyStartTm ;//option: no rest
						} else
							pilotStartTm[n][0] = pDutyStartTm[n][0] = inP->startInfoP->pilotAvail[n].dutyStartTm; //start time when available
					} else //redo travel
					{
						m = 0 ; //index for travel <= DL_MAX_NUM_TRAVEL_PER_PILOT

						//travel then rest
						if ( inP->pTm[n] < tZero - preFltTm[n] - Minute*optParam.minRestTm )
						{
							if( inP->startInfoP->pilotAvail[n].status )//resting now, travel late
							{
								if( !getCrewTravelDataLate(inP->pTm[n], tZero - preFltTm[n] - Minute*optParam.minRestTm, inP->pAirports[n], inP->acAirport, &departTm, 
								&dutyStartTm, &arrivalTm, &cost, withOag ))
								{
									_ASSERTE(cost && arrivalTm - dutyStartTm <= getCurMaxDutyTm(firstDuty[n], dutyStartTm, inP->pAirports[n] )) ;
									pDutyStartTm[n][m] = tZero - preFltTm[n] ;
									pilotStartTm[n][m] = dutyStartTm ;//travel start time
									tCosts[n][m] = cost ;
									m ++ ;
									_ASSERTE( m <= DL_MAX_NUM_TRAVEL_PER_PILOT );
								} 
							} else//active now, travel early
							{
								if( !getCrewTravelDataEarly(inP->pTm[n], tZero - preFltTm[n] - Minute*optParam.minRestTm, inP->pAirports[n], inP->acAirport
								, &departTm, &dutyStartTm, &arrivalTm, &cost, withOag ) )
								{
									_ASSERTE(cost) ;
									//need to check travel duty time
									if( arrivalTm  - inP->startInfoP->pilotAvail[n].dutyStartTm <= //Minute*optParam.maxDutyTm //active, duty time ok
										getCurMaxDutyTm(firstDuty[n], inP->startInfoP->pilotAvail[n].dutyStartTm, inP->pAirports[n] )
									|| inP->pTm[n] + Minute*optParam.minRestTm <= dutyStartTm ) //active, duty time violates, but can rest before travel starts
									{
										pDutyStartTm[n][m] = tZero - preFltTm[n] ;
										pilotStartTm[n][m] = dutyStartTm ;//travel start time
										tCosts[n][m] = cost ;
										m ++ ;
										_ASSERTE( m <= DL_MAX_NUM_TRAVEL_PER_PILOT );
									}
								} 
							}
						}//end if ( inP->pTm[n] < tZero - preFltTm[n] - Minute*optParam.minRestTm )
						
						//travel, then no rest
						if (  inP->pTm[n] < tZero - preFltTm[n]
						&& !getCrewTravelDataLate(inP->pTm[n], tZero - preFltTm[n], inP->pAirports[n], inP->acAirport, &departTm, &dutyStartTm, &arrivalTm
						, &cost, withOag ))
						{
							_ASSERTE(cost ); // &&  arrivalTm - dutyStartTm <= getCurMaxDutyTm(firstDuty[n], dutyStartTm, inP->pAirports[n])) ;

							if( tZero + minDutyTm - dutyStartTm <= getCurMaxDutyTm(firstDuty[n], dutyStartTm, inP->pAirports[n] )//Minute*optParam.maxDutyTm //total duty time after travel starts
							&& (inP->startInfoP->pilotAvail[n].status //resting
							|| tZero + minDutyTm  - inP->startInfoP->pilotAvail[n].dutyStartTm 
								<= getCurMaxDutyTm(firstDuty[n], inP->startInfoP->pilotAvail[n].dutyStartTm, inP->pAirports[n] ) //Minute*optParam.maxDutyTm //active, duty time ok
							|| inP->pTm[n] + Minute*optParam.minRestTm <= dutyStartTm )) //active, duty time violates, but can rest before travel starts
							{
								pilotStartTm[n][m] = pDutyStartTm[n][m] = dutyStartTm ;//use travel start time
								tCosts[n][m] = cost ;
								m ++ ;
								_ASSERTE( m <= DL_MAX_NUM_TRAVEL_PER_PILOT );
							}
						}

						if( !m ) //can't find feasible travels, or duty time infeasible, check to see if keep the original
						{
							//if( inP->startInfoP->type != DL_NewAvail && cpAcAssigns[inP->startInfoP->cpInd] != NULL && cpAcAssigns[inP->startInfoP->cpInd][dayOne].numAc 
							if( inP->cpAcAssignP && tZero == inP->lStartTm )//last tZero
							{
								_ASSERTE(inP->startInfoP->type != DL_NewAvail && *numAssignmentsP == 0) ;
								inP->keepOriginal = DL_KO_NoTravel ; //note: changed inP, OK since current tZero is the last tZero
							}
							break; ////////////////////////////////////////////////////////////tZero not feasible, will continue to the nexy tZero
						}//end if( !m )
						
					}//end redo travel
				}//end for(n=0; n < 2; n ++)
				if( n < 2 && !inP->keepOriginal ) //infeasible and not keeping the original duty, continue to the next tZero
					goto tZeroUpdate ;
			} 
///////////////////////////////////////////////////////////////////////////end check travels

			//if not first duty, or keep the original duty, set start time
			if( inP->day != inP->firstDay || inP->keepOriginal )
				for(n=0; n < 2; n ++)//for each pilot
				{
					if( inP->startInfoP->type != DL_NewAvail && inP->day > inP->startInfoP->legStartDay )//after first duty
						pilotStartTm[n][0] = pDutyStartTm[n][0] = tZero - Minute*optParam.preFlightTm ;
					else//same pre flight time as the first duty
						pilotStartTm[n][0] = pDutyStartTm[n][0] = tZero - preFltTm[n] ;
				}

			//_ASSERTE( keepOrigDuty || tZero + MinCrewInterval <= lateEndTm );
////////////////////////////////////////////////////////////////////////////////initialize the righ end
			if( inP->cpAcAssignP )//contain legs
			{
				tOne = inP->eEndTm ; 
				/*
				if( tZero == inP->lStartTm )//keep the original time interval
					tOne = inP->eEndTm ;
				else//make sure interval is bigger than the min crew interval
					tOne = max(inP->eEndTm, tZero + MinCrewInterval) ;
				*/
			} else
				tOne = tZero + MinCrewInterval ;
			//_ASSERTE( tOne <= inP->lEndTm || inP->cpAcAssignP );
			_ASSERTE( tOne <= inP->lEndTm );

			while ( cont ) //for tOne
			{
				//check total duty time
				if( !inP->keepOriginal )
				{
					for(m=0; m < DL_MAX_NUM_TRAVEL_PER_PILOT; m++)//first pilot's travel
					{
						if( pDutyStartTm[0][m] && tOne + Minute*optParam.postFlightTm -  pDutyStartTm[0][m] 
						<= getCurMaxDutyTm(firstDuty[0], pDutyStartTm[0][m], inP->pAirports[0]))
						{
							for(n=0; n < DL_MAX_NUM_TRAVEL_PER_PILOT; n++)//second pilot's travel
								if( pDutyStartTm[1][n] && tOne + Minute*optParam.postFlightTm -  pDutyStartTm[1][n] 
								<= getCurMaxDutyTm(firstDuty[1], pDutyStartTm[1][n], inP->pAirports[1]))
									break;
							if( n < DL_MAX_NUM_TRAVEL_PER_PILOT )
								break;
						}
					}
					if( m >= DL_MAX_NUM_TRAVEL_PER_PILOT ) //no fesible duty times found
					{
						if ( inP->cpAcAssignP && tZero == inP->lStartTm && tOne == inP->eEndTm) //if original duty assigned, fix tOne
						{
							_ASSERTE(inP->startInfoP->type != DL_NewAvail && *numAssignmentsP == 0) ;
							inP->keepOriginal = DL_KO_DutyTime ; //note
						} else
							break; //to the next tZero: tOne increasing --> next tZero is infeasible
					}
				}
				//end check total duty time

				//generate a temp column, containing covering info
				memset(&temCol, 0, sizeof(DL_Column) ); //initialize
				
				//check covered demands: they don't depend on the travels
				for(n=0; n < numDemand; n++)
				{
					//non-trivial, and demand end
					if( demandList[n].isAppoint || demandList[n].outAirportID == demandList[n].inAirportID )
						continue;

					m = inP->startInfoP->acTypeInd; //temp: ac type
					//upgrade and downgrade feasibility
					if( acTypeList[m].sequencePosn > (demandList[n].sequencePosn + max(demandList[n].maxUpgradeFromRequest, max(demandList[n].upgradeRecovery, acTypeList[m].maxUpgrades)))
					|| acTypeList[m].sequencePosn < demandList[n].sequencePosn - demandList[n].downgradeRecovery )
						continue;
					//get arrival time
					if( inP->acAirport != demandList[n].outAirportID )
					{
						getFlightTime( inP->acAirport, demandList[n].outAirportID, acTypeList[m].aircraftTypeID, month, 0, &flightTm, &blockTm, &elapsedTm, &numStops) ;
						if( ( tempTm = getRepoArriveTm( inP->acAirport, demandList[n].outAirportID,  (int)(tZero/Minute), elapsedTm )) == -1 )
							continue;
						arrivalTm = Minute*(tempTm + optParam.turnTime) ;
						cost = (flightTm*acTypeList[m].operatingCost)/Minute + (numStops+1)*acTypeList[m].taxiCost ;
					} else
					{
						arrivalTm = tZero ; //turn time
						cost = 0;
					}
					//time to cover this demand
					if( arrivalTm > demandList[n].reqOut + RecoverDeptDelay || demandList[n].reqIn +  max(0, arrivalTm - demandList[n].reqOut) > tOne )
						continue ;

					if( allocCvdDemForCL(&temCol) )
					{
						logMsg(dlFile,"%s Line %d, Out of Memory \n", __FILE__, __LINE__);
						exit(1);
					}

					temCol.coverDemCoefs[temCol.numCoverDems-1] = cost;//legP: covering cost
					temCol.coverDems[temCol.numCoverDems-1] = n; //demand index
				}//end for(n=0; n < numDemand; n++)
				
				//if( temCol.numCoverDems > 0 || ( inP->cpAcAssignP && tZero == inP->lStartTm && tOne == inP->eEndTm) ) //demands covered, or keep the original interval
				//{
					_ASSERTE( temCol.startTm == 0  ) ;
					noNewCol = 0 ; //new columns will be generated

					temCol.startInfoP = inP->startInfoP;
					temCol.cpAcAssignP = inP->cpAcAssignP ; //not null --> there are legs assigned
					//temCol.cpInd = startP->cpInd;
					temCol.firstDay = inP->firstDay;
					temCol.day = inP->day;
					temCol.startTm = tZero;
					temCol.endTm = tOne;
					
					temCol.acInd = inP->acInd;//first ac
					temCol.acAirport = inP->acAirport ;
					temCol.acTm = inP->acTm ;
					for(n=0; n<2; n++)
					{
						temCol.pAirports[n] = inP->pAirports[n] ;
						temCol.pTm[n] = inP->pTm[n] ;
					}
					temCol.keepOriginal = inP->keepOriginal ;
				//} else 
				//	goto tOneUpdate ; //continue to the next tOne

				//keepOriginal == 1 if this duty contains legs and
				//both start time and end time are fixed, or current duty time violates, or no feasible travels to the first leg start time
				//or no feasible travels for the original duty
				if( inP->keepOriginal )
				{
					_ASSERTE(inP->startInfoP->type != DL_NewAvail && *numAssignmentsP == 0) ;

					aP = allocAnAssignment( assignmentsP, numAssignmentsP);
					colMove( aP, &temCol ); //copy from temp col
					//set the difference
					for(n=0; n < 2; n ++)//for each pilot
					{
						if( inP->startInfoP->type != DL_NewAvail && inP->day > inP->startInfoP->legStartDay )
							aP->pilotStartTm[n] = aP->pDutyStartTm[n] = tZero - Minute*optParam.preFlightTm ;
						else
							aP->pilotStartTm[n] = aP->pDutyStartTm[n] = tZero - preFltTm[n] ;
					}
					newAssignCount ++;
				} else
				{
					//go through travels to generate actual assignments
					for(m=0; m < DL_MAX_NUM_TRAVEL_PER_PILOT; m++)
					{
						if( !pDutyStartTm[0][m]
						|| ( !temCol.keepOriginal && tOne + Minute*optParam.postFlightTm -  pDutyStartTm[0][m] 
						> getCurMaxDutyTm(firstDuty[0], pDutyStartTm[0][m], inP->pAirports[0])))
							continue ;

						for(n=0; n < DL_MAX_NUM_TRAVEL_PER_PILOT; n++)
						{
							if( !pDutyStartTm[1][n]
							|| ( !temCol.keepOriginal && tOne + Minute*optParam.postFlightTm -  pDutyStartTm[1][n] 
							> getCurMaxDutyTm(firstDuty[1], pDutyStartTm[1][n], inP->pAirports[1])))
								continue ;

							aP = allocAnAssignment( assignmentsP, numAssignmentsP);
							_ASSERTE( aP != NULL );

							colMove( aP, &temCol ); //copy from temp col
	
							//if( inP->startInfoP->type != DL_NewAvail )//test
							//	aP->cost = 0;
							//else
								aP->cost = tCosts[0][m] + tCosts[1][n] ; //travel costs

							aP->pilotStartTm[0] = pilotStartTm[0][m] ; //pilot start time
							aP->pilotStartTm[1] = pilotStartTm[1][n] ;
							aP->pDutyStartTm[0] = pDutyStartTm[0][m] ; //pilot duty start time before tZero
							aP->pDutyStartTm[1] = pDutyStartTm[1][n] ;

							newAssignCount ++;

						}//end for(n=0; n < DL_MAX_NUM_TRAVEL_PER_PILOT; n++)
					}//end for(m=0; m < DL_MAX_NUM_TRAVEL_PER_PILOT; m++)
				}//end else
				
				colFree( &temCol );//reset the temp column

//tOneUpdate:
				if( inP->keepOriginal )
					break;
				//update tOne
				if( tOne + DiscrtCrewInterval <= inP->lEndTm )
				{
					tOne += DiscrtCrewInterval ; //increase tOne
					_ASSERTE( tOne - tZero >= MinCrewInterval || inP->cpAcAssignP );
					
					/*
					_ASSERTE( tOne - tZero >= MinCrewInterval || ( inP->cpAcAssignP && tZero == inP->lStartTm )) ;//in order to keep the original interval

					//increase the interval more: if interval is small and increase is feasible
					while( tOne - tZero < MinCrewInterval && tOne + DiscrtCrewInterval <= inP->lEndTm )
						tOne += DiscrtCrewInterval ;
					
					//interval is big enough, or increase will violate
					if( tOne - tZero < MinCrewInterval )//interval is still small, break
						break;
					*/
				} else
					break;
			}//end for(tOne =

tZeroUpdate:
			if( inP->keepOriginal )
				break;
			if( tZero + DiscrtCrewInterval <= inP->lStartTm )
			{
				_ASSERTE( tZero + DiscrtCrewInterval + MinCrewInterval <= inP->lEndTm || inP->cpAcAssignP );
				tZero += DiscrtCrewInterval ;
			} else if (tZero < inP->lStartTm )
				tZero = inP->lStartTm ;
			else
				break;

			/*
			//update tZero
			if( tZero + DiscrtCrewInterval <= inP->lStartTm )
			{
				if( tZero + DiscrtCrewInterval + MinCrewInterval > inP->lEndTm )
				{
					tZero = inP->lStartTm ;
					_ASSERTE(inP->cpAcAssignP);
				} else
					tZero += DiscrtCrewInterval ;
			} else if( inP->cpAcAssignP && tZero < inP->lStartTm && tZero + DiscrtCrewInterval >= inP->lStartTm )//if current duty contains legs, then keep the late start time, to be consistent
				tZero = inP->lStartTm ;
			else
				break;
			*/
		}//end for(tZero
	}//end for(i=0; i < numTmpData; i ++)

	return noNewCol ;
}

static time_t getCurMaxDutyTm(const int firstDuty, const time_t curTime, const int curApt )
{
	int minutesAML ;
	const time_t fdReducedMaxDutyTm = 12*3600 ;
	const time_t adReducedMaxDutyTm = 10*3600 ;
	const int fdIntervalEnd = 480 ; // 8am local
	const int adIntervalEnd = 300 ; //6am local

	minutesAML = minutesPastMidnight(curTime, curApt) ;

	if( minutesAML < adIntervalEnd )
		return adReducedMaxDutyTm ;
	else if( firstDuty && minutesAML < fdIntervalEnd )
		return fdReducedMaxDutyTm ;
	else
		return Minute*optParam.maxDutyTm ;
}

static int colMove ( DL_Column *destP, const DL_Column *origP )
{

	_ASSERTE( origP != NULL );

	memmove( destP, origP, sizeof(DL_Column) );

	if( origP->numCoverDems > 0 )
	{
		_ASSERTE( origP->coverDems != NULL && origP->coverDemCoefs != NULL );
		if( !(destP->coverDems = (int *) calloc(origP->numCoverDems, sizeof(int))))
		{
			logMsg(dlFile,"%s Line %d, Out of Memory \n", __FILE__, __LINE__);
			exit(1);
		}
		memmove(destP->coverDems, origP->coverDems, origP->numCoverDems*sizeof(int) );

		if( !(destP->coverDemCoefs = (double *) calloc(origP->numCoverDems, sizeof(double))))
		{
			logMsg(dlFile,"%s Line %d, Out of Memory \n", __FILE__, __LINE__);
			exit(1);
		}
		memmove(destP->coverDemCoefs, origP->coverDemCoefs, origP->numCoverDems*sizeof(double) );
	}

	if( origP->numCoverRegions > 0 )
	{
		_ASSERTE( origP->coverRegions != NULL && origP->coverRegionCoefs != NULL );
		if( !(destP->coverRegions = (int *) calloc(origP->numCoverRegions, sizeof(int))))
		{
			logMsg(dlFile,"%s Line %d, Out of Memory \n", __FILE__, __LINE__);
			exit(1);
		}
		memmove(destP->coverRegions, origP->coverRegions, origP->numCoverRegions*sizeof(int) );

		if( !(destP->coverRegionCoefs = (double *) calloc(origP->numCoverRegions, sizeof(double))))
		{
			logMsg(dlFile,"%s Line %d, Out of Memory \n", __FILE__, __LINE__);
			exit(1);
		}
		memmove(destP->coverRegionCoefs, origP->coverRegionCoefs, origP->numCoverRegions*sizeof(double) );
	} 

	return 0;
}

static int colFree ( DL_Column *origP )
{
	if( origP->numCoverDems > 0 )
	{
		_ASSERTE( origP->coverDems != NULL && origP->coverDemCoefs != NULL );

		free( origP->coverDems );
		origP->coverDems = NULL ;

		free( origP->coverDemCoefs );
		origP->coverDemCoefs = NULL ;
	} else
		_ASSERTE( origP->coverDemCoefs == NULL && origP->coverDems == NULL ) ;

	if( origP->numCoverRegions > 0 )
	{
		_ASSERTE( origP->coverRegions != NULL && origP->coverRegionCoefs != NULL );

		free( origP->coverRegions );
		origP->coverRegions = NULL ;

		free( origP->coverRegionCoefs );
		origP->coverRegionCoefs = NULL ;
	} else
		_ASSERTE( origP->coverRegionCoefs == NULL && origP->coverRegions == NULL ) ;

	memset(origP, 0, sizeof(DL_Column) );

	return 0;
}


static DL_Column *allocAnAssignment(DL_Column **assignmentsP, int *countP)
{
	DL_Column *temP;

	if(!(*assignmentsP)) 
	{
		if( !((*assignmentsP) = (DL_Column *) calloc(NewAssignDefaultAllocSize, sizeof(DL_Column))))
		{
			logMsg(dlFile,"%s Line %d, Out of Memory \n", __FILE__, __LINE__);
			exit(1);
		}
		(*countP) ++ ;
		temP = (*assignmentsP);
		return temP;
	}

	if( ! ((*countP) % NewAssignDefaultAllocSize) )
	{
		if( !((*assignmentsP) = (DL_Column *) realloc(*assignmentsP, (NewAssignDefaultAllocSize + (*countP))*sizeof(DL_Column))))
		{
			logMsg(dlFile,"%s Line %d, Out of Memory \n", __FILE__, __LINE__);
			exit(1);
		}
	}

	temP = (*assignmentsP);
	temP += (*countP);
	(*countP) ++;
	
	memset(temP, 0 ,sizeof(DL_Column));
	return temP;

	//memset(&((*assignmentsP)[*countP-1]),'\0',sizeof(DL_Column));
	//return(&((*assignmentsP)[*countP-1]));
}

static DL_LpColumn *allocAnLpColumn(DL_LpColumn **lpColsP, int *countP)
{
	DL_LpColumn *temP;

	if(!(*lpColsP)) 
	{
		if( !((*lpColsP) = (DL_LpColumn *) calloc(TourColDefaultAllocSize, sizeof(DL_LpColumn))))
		{
			logMsg(dlFile,"%s Line %d, Out of Memory \n", __FILE__, __LINE__);
			exit(1);
		}
		(*countP) ++ ;
		temP = (*lpColsP);
		return temP;
	}

	if( ! ((*countP) % TourColDefaultAllocSize) )
	{
		if( !((*lpColsP) = (DL_LpColumn *) realloc(*lpColsP, (TourColDefaultAllocSize + (*countP))*sizeof(DL_LpColumn))))
		{
			logMsg(dlFile,"%s Line %d, Out of Memory \n", __FILE__, __LINE__);
			exit(1);
		}
	}

	temP = (*lpColsP);
	temP += (*countP);
	(*countP) ++;
	
	memset(temP, 0 ,sizeof(DL_LpColumn));
	return temP;
}

static DL_CpAcStartInfo *allocAStartInfo(DL_CpAcStartInfo **cpAcStartInfosP, int *countP)
{
	DL_CpAcStartInfo *temP;

	if(!(*cpAcStartInfosP)) 
	{
		if( !((*cpAcStartInfosP) = (DL_CpAcStartInfo *) calloc(DefaultAllocSize, sizeof(DL_CpAcStartInfo))))
		{
			logMsg(dlFile,"%s Line %d, Out of Memory \n", __FILE__, __LINE__);
			exit(1);
		}
		(*countP) ++ ;
		temP = (*cpAcStartInfosP);
		return temP;
	}

	if( ! ((*countP) % DefaultAllocSize) )
	{
		if( !((*cpAcStartInfosP) = (DL_CpAcStartInfo *) realloc(*cpAcStartInfosP, (DefaultAllocSize + (*countP))*sizeof(DL_CpAcStartInfo))))
		{
			logMsg(dlFile,"%s Line %d, Out of Memory \n", __FILE__, __LINE__);
			exit(1);
		}
	}

	temP = (*cpAcStartInfosP);
	temP += (*countP);
	(*countP) ++;
	
	memset(temP, 0 ,sizeof(DL_CpAcStartInfo));
	return temP;

}

static int *allocCvdDemForCL( DL_Column *inP)
{
	if( inP->coverDems == NULL ) 
	{
		_ASSERTE( !inP->numCoverDems && inP->coverDemCoefs == NULL ) ;
		if( !(inP->coverDems = (int*) calloc(IndAllocSize , sizeof(int))))
		{
			logMsg(dlFile,"%s Line %d, Out of Memory \n", __FILE__, __LINE__);
			exit(1);
		}
		if( !(inP->coverDemCoefs = (double*) calloc(IndAllocSize , sizeof(double))))
		{
			logMsg(dlFile,"%s Line %d, Out of Memory \n", __FILE__, __LINE__);
			exit(1);
		}
		inP->numCoverDems ++ ;
		return 0 ;
	}
	if( ! (inP->numCoverDems % IndAllocSize ) )
	{
		if( !( inP->coverDems = (int *) realloc(inP->coverDems, (IndAllocSize+inP->numCoverDems )*sizeof(int))))
		{
			logMsg(dlFile,"%s Line %d, Out of Memory \n", __FILE__, __LINE__);
			exit(1);
		}
		if( !( inP->coverDemCoefs = (double *) realloc(inP->coverDemCoefs, (IndAllocSize+inP->numCoverDems )*sizeof(double))))
		{
			logMsg(dlFile,"%s Line %d, Out of Memory \n", __FILE__, __LINE__);
			exit(1);
		}
	}
	inP->numCoverDems ++;
	memset(&(inP->coverDems[inP->numCoverDems-1]), 0, sizeof(int));
	memset(&(inP->coverDemCoefs[inP->numCoverDems-1]), 0, sizeof(double));
	return 0 ;
}

static int compareCpAcStartInfo (const DL_CpAcStartInfo *a, const DL_CpAcStartInfo *b)
{
	if( a->firstLegStart != b->firstLegStart )
		return (int)(a->firstLegStart - b->firstLegStart ) ;
	else if( a->cpInd != b->cpInd )
		return (a->cpInd - b->cpInd);
	else
		return (a->acAvail.ind - b->acAvail.ind);
}

static int compareLpColumn (const DL_LpColumn *a, const DL_LpColumn *b)
{
	if( a->col->acInd != b->col->acInd )
		return ( a->col->acInd - b->col->acInd );
	if( a->col->startInfoP->cpInd != b->col->startInfoP->cpInd )
		return ( a->col->startInfoP->cpInd - b->col->startInfoP->cpInd );
	if( a->col->day != b->col->day )
		return ( a->col->day - b->col->day) ;
	return( (int)(a->col->startTm - b->col->startTm) );
}

static int compareMgdLegsAC (const ProposedMgdLeg *a, const ProposedMgdLeg *b)
{
	if ( a->aircraftID != b->aircraftID )
		return (a->aircraftID - b->aircraftID);
	else
		return (int)(a->schedOut - b->schedOut);
}

static int compareLegInfoCP (const DL_LegInfo *a, const DL_LegInfo *b)
{
	if (a->leg->crewPairInd != b->leg->crewPairInd)
		return (a->leg->crewPairInd - b->leg->crewPairInd);
	else
		return (int)(a->leg->schedOut - b->leg->schedOut);
}


static int compareCrewAssign (const ProposedCrewAssg *a, const ProposedCrewAssg *b)
{
	if( a->crewID != b->crewID )
		return ( a->crewID - b->crewID ) ;
	else
		return (int)(a->startTm - b->startTm);
}

int getDemUsed(DL_DemUsedType **dlDemUsedP)
{
	int i, j, demInd, count;
	DL_DemUsedType *dlDemUsed=NULL; //when this demand is used in the opt solution

	if( !(dlDemUsed = (DL_DemUsedType *) calloc(numDemand , sizeof(DL_DemUsedType))))
	{
		logMsg(dlFile,"%s Line %d, Out of Memory \n", __FILE__, __LINE__);
		exit(1);
	}

	if( optParam.withFlexOS )
	{
		_ASSERTE( numOrigDem > 0 && numDemand >= numOrigDem );
		for( i=0; i < numOrigDem; i ++)
			_ASSERTE( origDemInfos[i].isAppoint || origDemInfos[i].numInd == 1 );//no copy for customer demand
		for( i=0; i < numDemand; i ++)
			_ASSERTE( demandList[i].isAppoint || origDemInfos[demandList[i].origDemInd].numInd == 1 );
	}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////new tour
	for(demInd=0; demInd < numDemand; demInd ++)
		if( outTimes[demInd] )//used in new tours
			dlDemUsed[demInd] = DL_DemInNewTour ;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////existing tour
	for(i = 0; i < numOptExgTours; i ++)//go through demand list of each opt existing tour
	{
		for (j=0; j<MAX_LEGS; j++)
		{
			if( ( demInd = optExgTours[i].demandInd[j] ) < 0 ) //end of the list
				break;

			if( demandList[demInd].isAppoint )//app/maint
			{
				_ASSERTE( outTimes[demInd] == 0 && !dlDemUsed[demInd] );
				outTimes[demInd] = demandList[demInd].reqOut ; //assume req out time
				inTimes[demInd] = demandList[demInd].reqIn ;
				dlDemUsed[demInd] = DL_DemInExgTour;
			} else
			{
				_ASSERTE( dlDemUsed[demInd] == DL_DemInNewTour);
				dlDemUsed[demInd] = DL_DemInExgTour; //re-write
			}
		}//end for (j=0; j<MAX_LEGS; j++)

		for (j=0; j<MAX_LEGS; j++)
		{
			if( ( demInd = optExgTours[i].demandInd2[j] ) < 0 )
				break;

			if( demandList[demInd].isAppoint )//app/maint
			{
				_ASSERTE( outTimes[demInd] == 0 && !dlDemUsed[demInd] );
				outTimes[demInd] = demandList[demInd].reqOut ; //assume req out time
				inTimes[demInd] = demandList[demInd].reqIn ;
				dlDemUsed[demInd] = DL_DemInExgTour;
			} else
			{
				_ASSERTE( dlDemUsed[demInd] == DL_DemInNewTour);
				dlDemUsed[demInd] = DL_DemInExgTour; //re-write
			}
		}//for (j=0; j<MAX_LEGS; j++)
	}//for(i = 0; i < numOptExgTours; i ++)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////app column
	if( optParam.withFlexOS )
	{
		for (i=0; i<numOrigDem; i++)//note
		{	
			if( optSolution[i] == 1 )//uncovered
			{
				for(j=0; j < origDemInfos[i].numInd; j ++)
					_ASSERTE( !dlDemUsed[origDemInfos[i].indices[j]] );
				continue ;
			}

			count = 0 ; //go through copies
			for(j=0; j < origDemInfos[i].numInd; j ++)
				if( dlDemUsed[origDemInfos[i].indices[j] ] )//this copy is used
					count ++;
			_ASSERTE( count == 0 || count == 1);

			if( count )//found used copy, skip, otherwise, a copy of thie orig dem must be contained in an app column
				continue;

			_ASSERTE( origDemInfos[i].isAppoint );

			for(j=0; j < origDemInfos[i].numInd; j ++)//go through copies to get
			{
				demInd = origDemInfos[i].indices[j] ;
				if( demandList[demInd].outAirportID == acList[origDemInfos[i].acInd].availAirportID ) //take the first match ( the earliest start time )
				{
					outTimes[demInd] = demandList[demInd].reqOut ;
					inTimes[demInd] = demandList[demInd].reqIn ;
					dlDemUsed[demInd] = DL_DemInAppCol ;
					break;
				}
			}//end for(j=0; j < origDemInfos[i].numInd; j ++)
			_ASSERTE( j < origDemInfos[i].numInd );
		}//end for (i=0; i<numOrigDem; i++)
	} else
	{
		for (i=0; i<numDemand; i++)
		{	
			if( optSolution[i] == 1 )//uncovered
			{
				_ASSERTE(  !dlDemUsed[i] );
				continue ;
			}

			if( outTimes[i] == 0 )
			{
				outTimes[i] = demandList[i].reqOut ;
				inTimes[i] = demandList[i].reqIn ;
				dlDemUsed[i] = DL_DemInAppCol ;
			}
		}//end for (i=0; i<numDemand; i++)
	}//end else

	//print
	for(i=0; i<numDemand; i++)
	{
		_ASSERTE( (outTimes[i] == 0 && inTimes[i] == 0 && !dlDemUsed[i] ) || ( outTimes[i] > 0 && inTimes[i] > outTimes[i] && dlDemUsed[i] ));

		if( dlDemUsed[i] == DL_DemInNewTour )
			fprintf(dlFile, "\n Demand %d, appointment type %d, Used in new tours \n", demandList[i].demandID, demandList[i].isAppoint );
		else if( dlDemUsed[i] == DL_DemInExgTour )
			fprintf(dlFile, "\n Demand %d, appointment type %d, Used in exg tours \n", demandList[i].demandID, demandList[i].isAppoint );
		else if( dlDemUsed[i] == DL_DemInAppCol )
			fprintf(dlFile, "\n Demand %d, appointment type %d, Used in app columns \n", demandList[i].demandID, demandList[i].isAppoint);
		else
		{
			_ASSERTE( !dlDemUsed[i] );
			fprintf(dlFile, "\n Demand %d, appointment type %d, Not used \n", demandList[i].demandID, demandList[i].isAppoint );
		}
	}//end for(i=0; i<numDemand; i++)

	*dlDemUsedP = dlDemUsed ;
	return 0;
}